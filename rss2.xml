<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/css" href="/public/css/rss.css" ?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[小胡子哥的个人网站]]></title>
    <link>http://www.barretlee.com/</link>
    <script xmlns="http://www.w3.org/1999/xhtml" src="/public/js/rss.js"></script>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[想法，随笔，思考，感叹，瞬间，笔记...]]></description>
    <pubDate>Sat Mar 21 2020 11:15:59 GMT+0800 (China Standard Time)</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[浅谈价值表达]]></title>
      <link>http://www.barretlee.com/blog/2019/12/17/the-value-of-expression/</link>
      <guid>http://www.barretlee.com/blog/2019/12/17/the-value-of-expression/</guid>
      <pubDate>Tue Dec 17 2019 13:25:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[还记得刚踏入职场时，最大的困惑是不清楚未来的成长路径是怎样的，在职场上，我的未来是什么？未来的路该怎么走？业界的那些大牛，到底有多牛？我离他们有多远？对此完全没有概念。]]>
      
      </description>
      <content:encoded><![CDATA[<p>领英中国近期推出了一个年度行家的榜单，关注我的朋友可能知道，我有幸入了榜。领英对行家的定义是，在自己的领域中，根据自身经验和知识，为他人答疑解惑，分享行业洞察，提供经验干货。简单来说，所谓的行家，就是善于思考，乐于发声的人。</p><p>我想，领英不乏这样的人，整个互联网更是不乏这样的人，我之所以能够进入这个榜单，还是因为当前领英在中国仍在发育阶段，现阶段在这个平台上表达的人偏少，所以才显得我这个活跃的人是个“行家”吧。</p><p>本文想跟大家分享几件事情，分别是：</p><ul><li>我在进入职场时所面临的的困惑，以及我的心态是如何转变的</li><li>在社交媒体上进行“表达”，我的看法和经历</li><li>分享下“不善言辞”的技术人如何进行职场表达</li></ul><h3 id="一、走出困惑"><a href="#一、走出困惑" class="headerlink" title="一、走出困惑"></a>一、走出困惑</h3><p>还记得刚踏入职场时，最大的困惑是不清楚未来的成长路径是怎样的，在职场上，我的未来是什么？未来的路该怎么走？业界的那些大牛，到底有多牛？我离他们有多远？对此完全没有概念。</p><p>相信很多人起初跟我一样，都会有类似的困惑，事实上，这几年在社交平台上也经常会收了不少朋友的私信，询问这方面的问题。究其原因，我认为有如下几点：</p><ul><li><strong>[自身问题] 涉猎不足。</strong> 刚刚走进职场，工作经验不足，遇到的问题少，踩过的坑偏少，因此看不清领域全貌</li><li><strong>[自身问题] 缺少沟通。</strong> 与市场、业务、团队和社区的互动不足，甚至缺失，信息摄入渠道单一，对领域的综合理解不够，缺少对领域发展风向的判断</li><li><strong>[行业问题] 发展过快。</strong> 技术的迭代十分迅速，技术栈更替快，经常给人一种学不过来的感觉，给新人的压力大</li><li><strong>[行业问题] 成长梯度不清晰。</strong> 前端是一个新兴领域，出现时间不长，在行业的沉淀也比较薄，这不利于新人找准下一个层级的位置</li></ul><p>过去几年时间，我从未停止学习和思考，不断从技术底层去理解新事物的诞生，同时结合业务去思考技术的价值，持续地思考和输出，几年下来让我不断对行业和技术有了更深的理解。当我得到了公司和同行认可的时候，当初的很多困惑也就消失了，心态也跟着转变了。</p><p>市场的竞争是恶劣的，对人的要求也在不断地提升，这就要求我们必须不断地改变自己来适应新的环境。相比刚踏入职场，如今的我淡定了许多。<strong>很多有难度的事情会放到五年这个跨度来看，不急于求成，稳稳的去拿每个阶段的结果，控制好风险，这样下来，事情大概率就会按照自己的预期发展了。</strong></p><h3 id="二、从技术表达到职场表达"><a href="#二、从技术表达到职场表达" class="headerlink" title="二、从技术表达到职场表达"></a>二、从技术表达到职场表达</h3><p>我是一个技术人，从 13 年开始就拿起笔杆子在网络上写作，那个时候还属于个人博客比较流行的阶段。由于长期深入浅出地写前端领域的技术博文，吸引了不少围观的群众和志同道合的工程师，慢慢地，也在这个领域越走越远。后来个人博客不怎么流行了，应该说互联网信息泛滥了，长篇内容铺天盖地，传播周期也越来越短，再加上技术内容同质化比较严重，慢慢地，我在社交媒体上的表达就从长篇转向了短篇和中长篇，表达平台从个人博客转战到了微博，当然，分享的内容了也有了比较多的变化，更加侧重于资源的分享和观点的输出。</p><p><strong>时间</strong></p><p>有人问我，每天在社交媒体上花费多少时间？其实，<strong>表达不需要很多时间，表达背后的思考需要</strong>。我是一个乐于分享的人，在平时的工作和生活中看到问题，我都会去思考问题的本质是什么，然后把思考的内容梳理出来，发布到社交平台上。有些内容会引发较多的讨论，阅读评论和互动比较占用时间。</p><p><strong>坚持表达</strong></p><p>我粗略地统计了下，近五年产出了长篇博文（含技术研究）约 300 篇，中篇思考约 500 篇，短微博（含技术分享）约 5000 条。这几年，我一直逼着自己去思考，而且是逼着自己产出有见地的内容，长期下来，很明显地感觉到，思辨能力有了质的提升，写作、沟通能力也大幅提升了。顺道值得一提的是，同时还在全网收获了六七万的关注量。</p><p><strong>坚持有价值的表达</strong></p><p>什么样的表达是有价值的？我认为，能够给我带来价值的分享，有两类，<strong>一类是消除知识势差</strong>，对工作和思考有帮助的知识，辨识度很高，我会关注一些能够持续产出有高性价比知识的博主，所谓高性价比，就是他们分享的内容可以被直接应用到我的工作上，或者对我认识某个领域起到很大的作用；<strong>另一类是消除认知偏差</strong>，能够站在一个较高的维度或者较宽的视野下，从宏观角度解释现象，而且还会凝练一些方法论，这种内容往往可以引发二次思考，很有价值。</p><p>个人在分享的时候，也会尽量表达这两类内容，而不是做纯粹的知识搬运工。</p><p><strong>表达后的信息反馈</strong></p><p>在输出的过程中，也会经常收到有价值的反馈，从而让我更进一步地思考；在思考的过程中，我会阅读大量的素材以提高思考的深度和广度，也认识了一帮志同道合的朋友。</p><p>就拿前几天的事儿来说吧，我在 LinkedIn 发了一个观点，讨论“为什么 PWA 技术在国内不愠不火”，有一位在国外有过调研和实践的网友回复了他掌握到的讯息，让我知道了这个技术为什么在某些国家可以火起来，以及如何在这类国家火起来，很有启发性。</p><p>事实上，像这样，在社交平台上因为表达而让自己觉得有进步的故事还挺多的。</p><p><strong>职场表达</strong></p><p>LinkedIn，我在上头活跃了一年，在这里表达让我认识了一帮前端领域圈子之外的朋友，应该算是意外的收获吧。</p><p>起初我只是把它当做一个职场表达的自留地，吐槽吐槽一些显得不够专业的猎头，喷一喷在厂里看到的不好的现象，也偶尔分析一些问题背后的本质，没想过有人会看我写的东西，不过坚持一年后，发现关注我的人越来越多，慢慢的，也就聊的多了。</p><p>我觉得领英是一个比较好的职场表达空间，只要是有价值或有见解的观点，很容易被同行和相关行业的人注意到，而且有深度的互动也可以促进和提升自己对于行业的理解，这很有价值。</p><h3 id="三、技术人表达"><a href="#三、技术人表达" class="headerlink" title="三、技术人表达"></a>三、技术人表达</h3><p>行外人对程序员的第一印象可能是，“不善言语、Geek、修电脑”，这不是没有道理的。程序员善于通过程序来表达想法，他们追求简单、高效和极致，可能因为长期理性表达的缘故，技术上的输出很有力道，但职场上的表达就显得比较脆弱了。</p><p>如何缓解这个问题？我觉得可以多在网络上与不同的人交流，也多在现实生活中与不同的人交流，保持开放的心态。同时，在持续表达和交流的过程中，建立稳定的输出渠道，打造自己的受众基础，不断收集外部对自己的有效反馈，形成一个健康稳定的正向循环。</p><p>交流是一门艺术，不同的人口味不一样，风格也不一样，对于沟通，有几点建议：</p><ul><li><strong>简洁且全面地表达。</strong> 日常的沟通过程中，使用凝练的内容表达自己的想法，让人可以最短时间内了解意图</li><li><strong>交流而非索取。</strong> 信息势差是存在的，使用交流的方式相互分享和探讨，而不是为了降低信息势差一味地索取信息</li><li><strong>多交流观点。</strong> 上等讨论是交流观点，中等讨论是谈论事件，低等讨论是评判个人</li></ul><h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p><strong>表达不是目的，价值表达才是目的。</strong> 在这个信息已经开始泛滥的互联网之中，我们可以输出更多有价值、有深度的内容，因为我们所在的平台、所在的环境，会因为我们这些微小的改变而变得更加美好。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/12/17/the-value-of-expression/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Coding 五年，我在阿里“啃”了块硬骨头]]></title>
      <link>http://www.barretlee.com/blog/2019/11/30/life-and-work-in-alibaba/</link>
      <guid>http://www.barretlee.com/blog/2019/11/30/life-and-work-in-alibaba/</guid>
      <pubDate>Sat Nov 30 2019 13:25:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[在阿里的日子过得太快，转瞬间已在指尖和键盘的 Coding 声中溜走了五年，这五年，我从青涩的小伙转身成为一个女娃娃的爹，也从略带内向的毕业生进化成了既能码又能撕的“胡子大叔”。]]>
      
      </description>
      <content:encoded><![CDATA[<p>大家好，我叫李靖，来自淘系技术部，是一名前端工程师。</p><p>在阿里的日子过得太快，转瞬间已在指尖和键盘的 Coding 声中溜走了五年，这五年，我从青涩的小伙转身成为一个女娃娃的爹，也从略带内向的毕业生进化成了既能码又能撕的“胡子大叔”。</p><h3 id="人可以累，心不能累"><a href="#人可以累，心不能累" class="headerlink" title="人可以累，心不能累"></a>人可以累，心不能累</h3><p>刚入职时，作为一名技术新人，负责 PC 版的淘宝首页，这块业务很特殊，它的受众很多，每天都有上亿的流量，系统的复杂度虽不是很高，但是风险特别大，而且需要与很多很多很多人交涉，我接手之时业务发生了一些变化，作业量很大，压力也很大，有来自业务方的压力，也有技术上的挑战，那段时间，连续一两个月，加班到晚上 1 点左右回家，而且 1 点以后还有可能收到业务方的电话。</p><p>有一天晚上，大概 11 点钟，整层楼只剩下我和我的主管，在优化一个技术细节问题，他其实已经陪我快一个星期了。多日的疲惫感让我一下子爆发了出来，那天晚上，我哽咽了，哭了，最后泣不成声，主管在旁边，他话不多，等我哭的差不多的时候，他告诉我，“成长是很累，但是人可以累，心不能累”。</p><p>这几年，我一直记着这段往事，也把那句话深深地刻在了心里。从那以后，不管是工作，还是生活，我都会尽量保持良好的心态，每每感觉心累的时候，都会想办法调节自己。</p><p>当工作和生活交织在一起的时候，也很容易把生活中的情绪带到工作上来，心中的不如意会像病毒一样占据大脑，压垮我们的心理防线。学会站得远一点来看待眼前，其实一切都会消逝，生活和工作都不会因为一点小事而变得黯淡无光，远方的路还很长。</p><h3 id="你相信吗？"><a href="#你相信吗？" class="headerlink" title="你相信吗？"></a>你相信吗？</h3><p>看不清前路的时候，鞭策自己的就是“相信”二字。</p><p>依稀记得刚来阿里的一两年，前头总有个师兄领着，完全不用担心迷路的事情，可不知道从什么时候开始，师兄好像成为了一团烟雾，弥散在了眼前，这才意识到，前方的路，需要自己去走。需要思考的问题越来越多，能得到的输入越来越少，我已经数不清自己有多少回看不清前路了，但每每看到一丝希望，都会紧紧地抓住，走下去。</p><p>做店铺业务的那年，我们团队人少事多，我负责的是 ISV 开放相关的技术支撑，旧的技术体系要过渡，新的方向要探索。在做规划的那段时间，我连闭上眼睛都能看到一堆让人头疼的问题在脑子里转来转去，后来我们决定把开发者的体验做上去，选择了一个非常难啃的技术领域——IDE 编辑器。当初我的内心是拒绝的，我认为自己搞不定，可实在也没有太多的路可以选择。</p><p>转岗吧，但回头一想，如果这块骨头不啃碎，ISV 技术支撑的体验很难有质的突破，团队的压力也会更大；另外再想一想，其实“好做”的事情都已经做得差不多了，大家都进入了深水区，没有那么多好啃的骨头。几个深呼吸以后，我决定，提起勇气，扎扎实实地干它一场。</p><p>那半年，时而痛苦，时而兴奋。庆幸的是，如期地帮助 ISV 解决了一些实际场景的问题。</p><p>当然，相信也是有条件的，当我把事情列清楚了，我多了一份相信；当我做出了一点点效果，又多了一份相信；当我得到了兄弟团队的关注和寻求合作的意向，我知道，当初的坚守是对的。大胆思考，小心求证，稳步向前地相信，前路才会越来越清晰。</p><h3 id="赋予工作多一点意义"><a href="#赋予工作多一点意义" class="headerlink" title="赋予工作多一点意义"></a>赋予工作多一点意义</h3><p>一线的研发工作，并不是每时每刻都充满着趣味和挑战，可以说日常的大部分时间都在处理琐碎的看似不起眼的脏活、苦活、累活。思维没打开，就好像囚禁在笼子里，看不清上下游关系，也看不到做这件事情的价值和意义。</p><p>工作的意义从来都不是别人赋予的，而是自我赋予。内心被人说服了，所以去做；看到了问题，所以去做；经历过痛苦产生了共情，所以去做。每一行代码、每一次优化、每一个变更，都期望能够让我们的用户更爽一点，用户爽了，我们的心里也就爽了。</p><p>近期的工作是解决前端工程相关的研发体验和效率问题，几乎每天都会听到来自不同 bu 的研发同学的声音，听到了他们的抱怨，也听到了他们的赞许，很多心声他们并不会全部吐露出来，但顺着反馈去看看是什么让他们爱不释手，是什么让他们痛不欲生，进而做出一些改变，这或许就是我给工作赋予的更多意义；而不是像不是一颗螺丝钉般，成天机械地解决来自用户、主管、合作伙伴提过来的各种需求。</p><p>世界没有太多的变化，但是用不一样的眼光去看待这个世界，可能会大大的不一样。</p><h3 id="五年，五味杂陈"><a href="#五年，五味杂陈" class="headerlink" title="五年，五味杂陈"></a>五年，五味杂陈</h3><p>在我们的人生中，有好多个五年，不长也不短。在这里，我度过了工作后的第一个五年，内容很丰富，这也让我意识到，未来需要以更长的跨度来规划阶段性的人生。</p><p>感谢这五年，感谢身边的人，也感谢阿里巴巴，让我受益良多~</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/11/30/life-and-work-in-alibaba/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[解密 VS Code 断点调试的原理]]></title>
      <link>http://www.barretlee.com/blog/2019/11/15/vscode-study-03-debug-protocol/</link>
      <guid>http://www.barretlee.com/blog/2019/11/15/vscode-study-03-debug-protocol/</guid>
      <pubDate>Fri Nov 15 2019 13:25:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>VS Code 相关系列的文章，近段时间已经写过三篇（<a href="https://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/">启动过程</a>，<a href="https://www.barretlee.com/blog/2019/10/23/vscode-study-01-start/">安装</a>，<a href="https://www.barretlee.com/blog/2019/11/01/vscode-study-02-debugging/">开发和调试</a>）了，后续还会在研究和学习的过程中持续输出，希望对感兴趣的读者带来一些帮助。</p><blockquote><p>我的文章风格一般都是持续挖掘底层原理，打破砂锅问到底，一直挖掘到大众能都理解的深度才会罢休，所以在做介绍的时候偶尔会跑个题讲讲其他相关的技术，主要也是为了给读者理解做好铺垫。</p></blockquote><p>平时我们经常会使用 Chrome 进行 JS 的断点调试，你是否有去思考过，为什么我打下一个断点，程序就会停下来，为什么在 VS Code 上不需要 Chrome Devtool 也能够断点，它背后是如何实现的？这就是文本要带你搞懂的东西。</p><h3 id="Node-js-的调试"><a href="#Node-js-的调试" class="headerlink" title="Node.js 的调试"></a>Node.js 的调试</h3><p>VS Code 上可以调试很多语言，安装对应的调试包即可，本文以 Node.js 为例，读者可以依葫芦画瓢，尝试下其他语言的调试，原理搞明白了，剩下的很多都是体力活。</p><p>首先，我们来看一看 Node.js 是如何被调试的，事实上本博客已经介绍过好多次了，这一次再更深入地探讨一下。</p><h4 id="连接-Node-js-的-Debugger"><a href="#连接-Node-js-的-Debugger" class="headerlink" title="连接 Node.js 的 Debugger"></a>连接 Node.js 的 Debugger</h4><p>在 6.3 版本以前的 Node.js，调试工具是比较单一的，社区比较活跃的调试工具叫 <code>node-inspector</code>，这玩意儿是个什么原理呢，为啥可以实现调试，我们可以通过几行简单的代码实现一个功能单一的 <code>node-inspector</code>，如下方是待调试的代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: test.js</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.write(<span class="string">'hello\n'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    res.end(<span class="string">'world'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'start server'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 <code>node --debug test.js</code> 启动程序，我们启动了一个 8888 端口的 HTTP Server。</p><blockquote><p>此处请通过 nvm 将 node 的版本号切换到 6.3 以下，如 <code>v6.2.2</code> 这个版本，后面会讲旧版 Node 和 v6.3+ 版本 Node 的区别。</p></blockquote><p>然后通过如下方式发起请求：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ curl 127.0.0.1:8888</span><br></pre></td></tr></table></figure><p>你会看到命令行只输出了 <code>hello\n</code>，然后就进入了 pending 状态，我们来分步理解下，为啥会这样：</p><ul><li>通过 <code>--debug</code> 参数启动 Node.js，程序会开启一个内置的 <code>Debugger</code> 模块</li><li>由于我们没有指定参数，<code>--debug=PORT</code>，默认使用的是 5858 端口，此时的 <code>Debugger</code> 模块会监听 5858 端口</li><li>在发起请求的时候，遇到 <code>debugger</code> 关键词，程序会暂停执行，直到收到“继续到下一步”的指令</li></ul><blockquote><p>Demo 的源码地址：<a href="https://github.com/barretlee/node-legacy-debug" target="_blank" rel="noopener">barretlee/node-legacy-debug</a></p></blockquote><p>我们可以编写一个程序看看 <code>Debugger</code> 模块具体干了什么：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: debugClient.js</span></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = net.createConnection(<span class="number">5858</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line">socket.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> json = data.toString();</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">`Content-Length: <span class="subst">$&#123;Buffer.byteLength(json, <span class="string">'utf8'</span>)&#125;</span>\r\n\r\n<span class="subst">$&#123;json&#125;</span>`</span>;</span><br><span class="line">  socket.write(msg, <span class="string">'utf8'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通过 <code>Net</code> 模块连接到刚才程序在 5858 端口开启的监听，刚连接上的时候，它会打印如下信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Type:</span> <span class="string">connect</span></span><br><span class="line"><span class="attr">V8-Version:</span> <span class="number">5.0</span><span class="number">.71</span><span class="number">.52</span></span><br><span class="line"><span class="attr">Protocol-Version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Embedding-Host:</span> <span class="string">node</span> <span class="string">v6.2.2</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>意思是告诉你，你尝试与 Debugger 模块连接，已经连接成功了，当前 debug 的程序所使用的 V8 版本号是 <code>5.0.71.52</code>，使用的协议版本是 <code>1</code>，Node 的版本号是 <code>v6.2.2</code>，这个信息其实就是在告诉你，该使用什么协议与调试程序进行通讯，<code>v6.2.2</code> 的版本所用到的协议是 <a href="https://github.com/buggerjs/bugger-v8-client/blob/master/PROTOCOL.md" target="_blank" rel="noopener">V8 Debugger Protocol</a>。</p><blockquote><p>为了打印全面的信息，注意操作的次序，先使用 debug 模块启动程序 test.js，然后启动 debugClient.js，最后再执行 curl 发起请求。</p></blockquote><p>在 curl 发起请求的时候，Debugger 会给 debugClient 发送一个消息：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Content-Length: 283</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">0</span>,<span class="attr">"type"</span>:<span class="string">"event"</span>,<span class="attr">"event"</span>:<span class="string">"break"</span>,<span class="attr">"body"</span>:&#123;<span class="attr">"invocationText"</span>:<span class="string">"#&lt;Timeout&gt;._onTimeout()"</span>,<span class="attr">"sourceLine"</span>:<span class="number">9</span>,<span class="attr">"sourceColumn"</span>:<span class="number">4</span>,<span class="attr">"sourceLineText"</span>:<span class="string">"    debugger;"</span>,<span class="attr">"script"</span>:&#123;<span class="attr">"id"</span>:<span class="number">59</span>,<span class="attr">"name"</span>:<span class="string">"/path/to/test.js"</span>,<span class="attr">"lineOffset"</span>:<span class="number">0</span>,<span class="attr">"columnOffset"</span>:<span class="number">0</span>,<span class="attr">"lineCount"</span>:<span class="number">18</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>刚才的 <code>curl</code> 不是进入 pending 了么，我们尝试给 Debugger 发一个指令（参考<a href="https://github.com/buggerjs/bugger-v8-client/blob/master/PROTOCOL.md#request-continue---continuerequest_" target="_blank" rel="noopener">协议内容</a>），告诉它进入下一个断点，内容为：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">1</span>,<span class="attr">"type"</span>:<span class="string">"request"</span>,<span class="attr">"command"</span>:<span class="string">"continue"</span>&#125;</span><br></pre></td></tr></table></figure><p>在 debugClient 中我们监听了 <code>process.stdin</code>，所以可以直接将上述内容粘贴到命令行回车即可，同时你也会看到 Debugger 发过来的反馈：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">1</span>,<span class="attr">"request_seq"</span>:<span class="number">1</span>,<span class="attr">"type"</span>:<span class="string">"response"</span>,<span class="attr">"command"</span>:<span class="string">"continue"</span>,<span class="attr">"success"</span>:<span class="literal">true</span>,<span class="attr">"running"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><p>告诉你，已经成功进入到了下一个断点，此时，你也会看到 curl 已经把 <code>world</code> 给输出了。</p><p>上面的程序，你可以在命令行输入其他指令，比如在暂停的时候查询 req 的 url 的值：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">2</span>,<span class="attr">"type"</span>:<span class="string">"request"</span>,<span class="attr">"command"</span>:<span class="string">"evaluate"</span>,<span class="attr">"arguments"</span>:&#123;<span class="attr">"expression"</span>:<span class="string">"req.url"</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>你会收到如下回复：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Content-Length: 177</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">3</span>,<span class="attr">"request_seq"</span>:<span class="number">2</span>,<span class="attr">"type"</span>:<span class="string">"response"</span>,<span class="attr">"command"</span>:<span class="string">"evaluate"</span>,<span class="attr">"success"</span>:<span class="literal">true</span>,<span class="attr">"body"</span>:&#123;<span class="attr">"handle"</span>:<span class="number">150</span>,<span class="attr">"type"</span>:<span class="string">"string"</span>,<span class="attr">"value"</span>:<span class="string">"/"</span>,<span class="attr">"length"</span>:<span class="number">1</span>,<span class="attr">"text"</span>:<span class="string">"/"</span>&#125;,<span class="attr">"refs"</span>:[],<span class="attr">"running"</span>:<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><p>在你的脑海中是不是已经出现了平时调试 Node.js 的画面了，没错，它的原理就是这样的。</p><h4 id="node-inspector，调试代理"><a href="#node-inspector，调试代理" class="headerlink" title="node-inspector，调试代理"></a>node-inspector，调试代理</h4><p>调试原理大概已经弄明白了，但是我相信没有几个人愿意通过上面的方式来调试程序，因为那实在是太麻烦了，不仅得知道各种指令的名称，还得知道指令的参数、协议的规范、sequence 的计数等等，因此就有了 <code>node-inspector</code>，它可以帮助我们在 Chrome Devtool 上可视化地调试 Node.js 程序，那么它干了什么事情呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                   +-----------------+</span><br><span class="line">                                   |  Node Program   |</span><br><span class="line">                                   +---------+-------+</span><br><span class="line">                                             ^</span><br><span class="line">                                             |</span><br><span class="line">+-----------------+                +---------+-------+</span><br><span class="line">|  Chrome Devtool |                | Node.js Debugger|</span><br><span class="line">+--------+--------+                +---------+-------+</span><br><span class="line">         |                                   ^</span><br><span class="line">         |                                   |</span><br><span class="line">       CRDP                                 V8DP</span><br><span class="line">         |      +-------------------+        |</span><br><span class="line">         +-----&gt;+   node inspector  +--------+</span><br><span class="line">                +-------------------+</span><br><span class="line"></span><br><span class="line">CRDP: Chrome Remote Debugging Protocol</span><br><span class="line">V8DP: V8 Debugging Protocol</span><br></pre></td></tr></table></figure><p>简单来说，<code>node inspector</code> 通过 Chrome 的 <code>Remote Debugging Protocol</code> 与 Chrome Devtool 建立了通道，然后通过 <code>V8 Debugging Protocol</code> 与程序的 <code>Debugger</code> 模块建立了连接，于是开发者就可以在 Chrome 上通过可视化操作来实现 Node.js 的调试了，所以我称它为“调试代理”，就是一个协议中转服务。</p><p>由于 <code>node-inspector</code> 很大程度提升了 Node 的调试体验，在 v6.3 的时候，Node.js 官方直接把这个能力给整合了进去。你会看到使用 v6.3+ 的 Node.js 中调试程序时，它会打印一个适配了 CRDP 协议的 webscoket 链接：</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">➜ node --<span class="keyword">inspect</span> <span class="keyword">test</span>.js</span><br><span class="line">Debugger listening <span class="keyword">on</span> ws:<span class="comment">//127.0.0.1:9229/db309268-623a-4abe-b19a-c4407ed8998d</span></span><br><span class="line"><span class="keyword">For</span> <span class="keyword">help</span> see https:<span class="comment">//nodejs.org/en/docs/inspector</span></span><br></pre></td></tr></table></figure><p>我们可以直接在 Chrome Devtool 上配置这个地址进入可视化调试，于是整个链路就变成了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+       +----------------+</span><br><span class="line">|                  |       |                |</span><br><span class="line">|  Chrome Devtool  |       |  Node Program  |</span><br><span class="line">|                  |       |           +-----------+</span><br><span class="line">+--------+---------+       +-----------+  Debugger |</span><br><span class="line">         |                             +-----+-----+</span><br><span class="line">         |                                   ^</span><br><span class="line">         |               CRDP                |</span><br><span class="line">         +-----------------------------------+</span><br></pre></td></tr></table></figure><p>少了调试代理的接入，开发者使用起来会轻松很多，而且 CRDP 规范在社区使用非常频繁，实现上有很多代码可以参考。</p><p>讲到这里，如果我们要自己实现一个可视化调试的界面，是不是就有点清晰了，：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+        +----------------+</span><br><span class="line">|                 |        |                |</span><br><span class="line">|     My IDE      |        |  Node Program  |</span><br><span class="line">|      +----------+---+    |           +----+------+</span><br><span class="line">+------| Debug Client |    +-----------+  Debugger |</span><br><span class="line">       +----------+---+                +-----+-----+</span><br><span class="line">                  |                          ^</span><br><span class="line">                  |            CRDP          |</span><br><span class="line">                  +--------------------------+</span><br></pre></td></tr></table></figure><p>只需要实现下图的 <code>Debug Client</code> 部分，以及 <code>Debug Client</code> 与 IDE 的视图进行联动，就可以实现自定义的可视化的调试了。</p><blockquote><p>如果你的需求是自定义 Node.js 的可视化调试，本文看到这里就可以结束了，相信你利用上面学到的知识完全有能力去实现一个调试界面。但是在 VS Code 中，我们有必要再展开更多的篇幅。</p></blockquote><h3 id="Debug-Adaptor-Protocol"><a href="#Debug-Adaptor-Protocol" class="headerlink" title="Debug Adaptor Protocol"></a>Debug Adaptor Protocol</h3><p>实现一个 Debug Client 其实成本挺高的，你需要吃透所有的调试协议，如 V8 Debugging Protocol，包含了几十个指令，每个指令都需要进行通讯适配和 UI 适配，这还只是一种语言，如果你的 IDE 面向多种语言，你就需要适配多种调试协议，不同协议之前的差异可能还挺大的，这些工作完全会让你崩溃。</p><p>另外，站在社区的角度，这种建设是可以被抽象的，试想一下，Atom 调试 Node.js 需要自己实现一个 Debug Client，Sublime Text 如此、VS Code 如此，你自建 IDE 也是如此，是不是完全没必要，因此就有了 <code>Debug Adaptor Protocol</code>，它是微软提出的一套 <a href="https://microsoft.github.io/debug-adapter-protocol/" target="_blank" rel="noopener">通用调试协议</a>，目前已经成为了社区的事实标准。</p><p>那这个 DAP 在调试的哪一层呢？我们可以看看这张图（<a href="https://microsoft.github.io/debug-adapter-protocol/overview" target="_blank" rel="noopener">来源</a>）：</p><p><img src="/blogimgs/2019/11/15/dap.png" alt="DAP"></p><p>在 IDE 上仅实现一次对 DAP 协议的通讯和 UI 适配，就可以调试所有的语言，你需要做的只有：</p><ul><li>社区有目标语言的 DAP 实现么，如果有，直接拿过来用，可以快速适配，搞定调试</li><li>如果没有，利用上面我们学到的知识，实现一个 DA，贡献给社区</li></ul><p>这套协议规范了 5 块内容：</p><ul><li><code>Base Protocol</code>，描述了请求、响应、事件、出错等通讯格式</li><li><code>Events</code>，描述了初始化、完成配置、输出、断点、停止等十几种事件标准</li><li><code>Request</code>，描述了调试的各种指令的请求格式</li><li><code>Response</code>，描述了调试的各种指令的响应格式</li><li><code>Types</code>，描述了以上各种内容中涉及到的类型和接口描述</li></ul><p>原则上，规范中提到的内容都需要在 DA 中实现，即便语言的底层引擎中没有这种能力，也应该抛一个错误出来，这样才能保证一致性。</p><h3 id="实现一个-Node-js-的调试器"><a href="#实现一个-Node-js-的调试器" class="headerlink" title="实现一个 Node.js 的调试器"></a>实现一个 Node.js 的调试器</h3><p>为了搞懂上面提到的几个协议，我动手写了一个 DEMO，实现了一个最简单的操作：展示当前 Debug 的堆栈信息，如下图所示：</p><p><img src="/blogimgs/2019/11/15/debug-tracker.png" alt="Debug Demo"></p><blockquote><p>仓库地址是：<a href="https://github.com/barretlee/node-debug" target="_blank" rel="noopener">barretlee/node-debug</a></p></blockquote><p>可以下载下来跑一下，下载依赖后启动即可：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">run</span> init;</span><br><span class="line">npm <span class="built_in">run</span> start;</span><br><span class="line"><span class="built_in">open</span> http:<span class="comment">//127.0.0.1:4445</span></span><br></pre></td></tr></table></figure><p>这个 Demo 的完成度很低，而且关键环节都是 Mock 的，只是为了帮助自己理解整个过程，理解以后就没有继续去完善细节了，感兴趣的同学可以研究下。</p><p>我没有自己去实现完整一个 Node.js Debug Adaptor，倒不是因为复杂，直接去研究了下 VS Code 开源了两个 Adaptor，分别是：</p><ul><li><a href="https://github.com/microsoft/vscode-node-debug.git" target="_blank" rel="noopener">vscode-node-debug</a>，这个是对 v6.3 以下版本的实现</li><li><a href="https://github.com/microsoft/vscode-node-debug2.git" target="_blank" rel="noopener">vscode-node-debug2</a>，这个是对 v6.3 及以上版本的实现</li></ul><p>根据连接时返回的 <code>Embedding-Host</code> 信息来选择使用哪个版本，VS Code 好像会默认安装这两个包。整体思路跟我上面提到的是一样的。</p><h3 id="VS-Code-的具体实现"><a href="#VS-Code-的具体实现" class="headerlink" title="VS Code 的具体实现"></a>VS Code 的具体实现</h3><p>调试程序有两种方式，一种是调试已经启动的程序，另一种是调试未启动的程序，前者 VS Code 会直接 <code>attach</code> 上去，后者会先 fork 一个进程 <code>launch</code> 程序，这里只稍微介绍 VS Code 实际操作过程中的几个知识点：</p><h4 id="程序启动时没有带-debug-参数"><a href="#程序启动时没有带-debug-参数" class="headerlink" title="程序启动时没有带 debug 参数"></a>程序启动时没有带 debug 参数</h4><p>如果 Node.js 程序在启动的时候没有带 <code>--debug</code> 或者 <code>--inspect</code> 参数，默认情况下 Node.js 的 Debugger 模块是不会启动的，这种情况下并非就不能调试了，我们可以手动来启动调试模块：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到对应的 Node.js 进程的 PID</span></span><br><span class="line">➜ ps -aux | grep <span class="string">'node'</span></span><br><span class="line"><span class="comment"># 给这个 PID 发送 SIGUSR1 信号</span></span><br><span class="line">➜ <span class="built_in">kill</span> -SIGUSR1 NODE_PID</span><br></pre></td></tr></table></figure><h4 id="stopOnEntry"><a href="#stopOnEntry" class="headerlink" title="stopOnEntry"></a>stopOnEntry</h4><p>在 fork 一个 Node.js 进程进行调试的时候，有两类入参：</p><ul><li><code>--debug</code> 和 <code>--inspect</code>，默认执行程序</li><li><code>--debug-brk</code> 和 <code>--inspect-brk</code>，默认在第一行直接断点</li></ul><p>一般来说我们都会选择第一种，如果你的程序会直接执行完成，速度很快，可以考虑第二种方式进行调试。</p><h4 id="VS-Code-连接-Node-js-调试进程的方式"><a href="#VS-Code-连接-Node-js-调试进程的方式" class="headerlink" title="VS Code 连接 Node.js 调试进程的方式"></a>VS Code 连接 Node.js 调试进程的方式</h4><p>VS Code 调试 Node.js 的 Debug Adaptor 核心内容在 <a href="https://github.com/microsoft/vscode-chrome-debug-core" target="_blank" rel="noopener">vscode-chrome-debug-core</a> 这个包中，它实际上是一个 Chrome Remote Debugging Protocol 的具体实现，<em>内部逻辑很多，看起来有点吃力</em>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>好吧，先写到这里，还有很多细节问题就不一一叙述了，价值不大，写这篇文章做了不少前期工作，对 DAP 和 Node.js 的 Debugger 研究了好几个晚上，不过总算是搞的比较明白了，如果你在测试的时候遇到什么疑问，欢迎在 <a href="#comment">下方</a> 留言。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/11/15/vscode-study-03-debug-protocol/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[一个刚毕业的计算机相关专业学生，简历上有哪些经历会加分？]]></title>
      <link>http://www.barretlee.com/blog/2019/11/07/resume-writing/</link>
      <guid>http://www.barretlee.com/blog/2019/11/07/resume-writing/</guid>
      <pubDate>Thu Nov 07 2019 12:01:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[有同学问我如何让简历加分，事实上这个问题之前分享过，再总结一下。下面的描述更多的是偏向于社招，不过对学生而言也有一定的参考价值。]]>
      
      </description>
      <content:encoded><![CDATA[<p>有同学问我如何让简历加分，事实上这个问题之前分享过，再总结一下。<strong>下面的描述更多的是偏向于社招，不过对学生而言也有一定的参考价值。</strong></p><p>首先简历这个东西，只是一个敲门砖，我们的目的是让面试官看上去产生好感，然后给我们一个面试的机会，简历不需要表达全部的自己，面试官一定是从面试中获取大量的情报来深入了解你。所以简历写到什么程度，我们的目标是相当明确的。</p><p><strong>如何从简历中让人看出你【做成了】什么，以及你未来【可能做成】什么，以下几点可以参考</strong>：</p><ul><li>表达一件有挑战的完整的事情，比如实现了一个平台的架构推导和落地，再如使用三个月时间经历四轮优化将系统的整体性能提升了 1.5 倍等等；而不是我写了某个网站的前端，沉淀了五个通用组件等等；</li><li>展示你跨专业的特性，比如作为前端工程师，我在运维工作上做了比较突出的贡献；在图形图像方面有深入研究和良好产出；曾并发管理 5 个中型项目并保证准时交付等等；</li><li>从业务价值的角度去发现问题和分析问题，比如通过融合两个相似系统后，降低了运营的成本，提高了数据从线下到线上展示的效率等；而不是简单地说，实现了数据层的合并，统一了前台交互等这种纯技术的表达；</li></ul><p><strong>说到底，还是需要让面试官看到你这几方面的能力</strong>：</p><ol><li>技术综合能力/学习能力（硬实力）</li><li>业务洞察力（理解力）</li><li>拿结果的能力（执行力）</li></ol><p><strong>看过不少简历，优秀的人大概都有这么一些特征（具备两三条甚至更多）</strong>：</p><ol><li>名企呆过，有大厂背书</li><li>参与的项目非常有震撼力</li><li>在技术领域跨度大的项目有成绩</li><li>有门槛的技术领域里有沉淀</li><li>技术产出对团队/业务有突出的影响</li><li>接二连三的专利</li><li>拿过一些很难拿到的奖项</li><li>非常好的韧劲，某一/几件事情上坚持不懈</li><li>思考力惊人，行动力惊人</li><li>思维敏捷且逻辑无比严谨</li><li>具备一定的社区影响力</li></ol><p>希望对你有些帮助。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/11/07/resume-writing/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[带你开发和调试 VS Code 源码]]></title>
      <link>http://www.barretlee.com/blog/2019/11/01/vscode-study-02-debugging/</link>
      <guid>http://www.barretlee.com/blog/2019/11/01/vscode-study-02-debugging/</guid>
      <pubDate>Fri Nov 01 2019 17:43:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p><a href="https://www.barretlee.com/blog/2019/10/23/vscode-study-01-start/">上文</a> 给大家介绍了如何在本地从源码启动 VS Code，笔者在更换电脑后重新安装依赖时又遇到了文中插曲里提到的问题，VS Code 依赖的很多资源都在 Github 上，而且有好几个模块都需要下载源码重新编译，安装依赖失败的概率还是略大的。</p><p>如果依赖的包构建失败，不用担心，等到启动的时候它会提示详细错误：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[<span class="number">92850</span>:<span class="number">1031</span>/<span class="number">221458.947969</span>:INFO:CONSOLE(<span class="number">17</span>)] </span><br><span class="line"><span class="comment">"Error: The module '~/vscode/node_modules/spdlog/build/Release/spdlog.node'</span></span><br><span class="line">was compiled against <span class="keyword">a</span> different Node.js <span class="keyword">version</span> using</span><br><span class="line">NODE_MODULE_VERSION <span class="number">73</span>. This <span class="keyword">version</span> of Node.js requires</span><br><span class="line">NODE_MODULE_VERSION <span class="number">69</span>. Please <span class="keyword">try</span> re-compiling <span class="built_in">or</span> re-installing</span><br></pre></td></tr></table></figure><p>如上，是 <code>spdlog</code> 安装失败了，可以通过 <code>yarn add spdlog</code> 重新安装，如果一直报错，请注意 Node.js 的版本，我使用的是 <code>v10.6.0</code>，编译的是 tag 为 <code>1.39.2</code> 的 VS Code 源码，没遇到问题。</p><blockquote><p>测试过几次，当我切换 VS Code 的版本（git tag）时，似乎 spdlog 和 vscode-sqlite3 这两个包的安装总是存在问题，按照上述方式重新安装和编译下就行了。</p></blockquote><h3 id="Main-和-Renderer"><a href="#Main-和-Renderer" class="headerlink" title="Main 和 Renderer"></a>Main 和 Renderer</h3><p>倘若你之前没有 Electron 的开发经验，这个段落不容错过。</p><blockquote><p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。</p></blockquote><p>Electron 是个什么东西？官方对它的定义是：“使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用”。</p><p><img src="/blogimgs/2019/11/01/electreon-structure.png" alt="Electron Structure"></p><p>打开 Electron 的 <a href="https://electronjs.org/docs" target="_blank" rel="noopener">文档</a>，从文档目录中，你大致就能够知道 Electron 可以做什么。Electron 有两大模块，<code>Main Process</code> 和 <code>Renderer Process</code>，暴露出来的上层 API 并不多，我数了一下，约摸 30 个。搞懂这 30 个 API 可能不是什么难事，但是在搞清楚 API 之前，我们需要先知道这两大模块之间是如何交互和协作的，以帮助我们更好地理解。</p><p>打开官方的 quick start demo：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</span><br><span class="line"><span class="comment"># 进入仓库</span></span><br><span class="line">$ <span class="built_in">cd</span> electron-quick-start</span><br><span class="line"><span class="comment"># 安装依赖库</span></span><br><span class="line">$ npm install</span><br><span class="line"><span class="comment"># 运行应用</span></span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure><p>你会看到两个核心文件，一个是 <code>main.js</code>，另外一个是 <code>index.html</code>，你完全可以这么理解：前者跑的是 Main Process，它的执行环境是一个 <code>Node</code> 环境；后者跑的是 Renderer Process，它的执行环境是一个 <code>Chromium + Node</code> 环境，也就是说，我们写的 <code>index.html</code> 中可以去调用 Node.js 的模块，这也是 Electron 与普通浏览器的主要差别。</p><p>Main 进程中可以通过 <code>BrowserWindow</code> 实例化多个 Renderer 进程，且每个 Renderer 进程相关独立，在复杂的项目中会涉及到了很多通信问题，比如 Main-Renderer 通讯，Renderer-Main 通讯，Renderer-Renderer 通讯，VS Code 中就有很多这类问题的优秀解决方案，不过不在我们今天的讨论范畴中。</p><p>Main 和 Renderer 之间的关系，可以用这种图来形容（<a href="http://jlord.us/essential-electron/" target="_blank" rel="noopener">图片来源</a>）：</p><p><img src="/blogimgs/2019/11/01/main-and-renderer.png" alt="Main and Renderer"></p><p>对于 Electron，先了解这么多知识，如果你期望了解更多，可以移步 <a href="https://electronjs.org/docs" target="_blank" rel="noopener">Electron 官方文档</a>。</p><h3 id="初识-VS-Code"><a href="#初识-VS-Code" class="headerlink" title="初识 VS Code"></a>初识 VS Code</h3><p>很多同学对 VS Code 已经熟悉得不能再熟悉了，谈不上初识，不过我们这里说的“初识”是针对它的架构和源码，相信对大多数人来说，它依然是陌生的。</p><p>先看看项目的整体目录结果，过滤了几个次要项：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── azure-pipelines.yml</span><br><span class="line">├── build/</span><br><span class="line">├── extensions/</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── out/</span><br><span class="line">├── package.json</span><br><span class="line">├── product.json</span><br><span class="line">├── resources/</span><br><span class="line">├── scripts/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   └── vs</span><br><span class="line">│       ├── base/</span><br><span class="line">│       ├── code/</span><br><span class="line">│            ├── browser/</span><br><span class="line">│                 ├── workbench.ts</span><br><span class="line">│                 └── workbench/workbench.html</span><br><span class="line">│            ├── electron-browser/</span><br><span class="line">│                 ├── workbench.js</span><br><span class="line">│                 └── workbench/workbench.html</span><br><span class="line">│            └── electron-main/</span><br><span class="line">│                 ├── main.ts</span><br><span class="line">│                 └── window.ts</span><br><span class="line">│       ├── editor/</span><br><span class="line">│       ├── platform/</span><br><span class="line">│       ├── server/</span><br><span class="line">│       └── workbench/</span><br><span class="line">└── test/</span><br></pre></td></tr></table></figure><p>上面这一坨看起来有点多，不过捋清楚了，也就好理解了，下面我们就一个一个地解释下：</p><ul><li><code>azure-pipelines.yml</code>，看名字就知道是啥意思，它是一个 CI/CD 的配置，自动测试、构建、打包</li><li><code>build/</code>，这里面放的是 VS Code 项目的构建工具，相对来说还是比较复杂的，主要是因为它顾及了 Linux/Mac/Windows 三个平台</li><li><code>extensions/</code>，VS Code 的内置模块，包含各种语言高亮的 LSP 相关模块</li><li><code>gulpfile.js</code>，构建脚本，暂时不用细看，可以关注 <code>package.json</code> 的 scripts，里面放着一些程序的快捷启动方式，而且针对内存溢出做了防御，如 <code>--max_old_space_size=4095</code></li><li><code>out/</code>，构建的结果都放在这个目录下</li><li><code>package.json</code>，需要着重看看 <code>main</code> 和 <code>scripts</code> 两个字段</li><li><code>product.json</code>，如果你想根据 VS Code 进行二次开发，建立自己的品牌，建议搞懂这个文件，因为你需要修改它</li><li><code>resource/</code>，打包构建生成安装包（exe/dmg/deb 等）的时候需要依赖的额外资源</li><li><code>scripts/</code>，开发过程各种会用到的脚本，用的比较多的可能是 <code>./scripts/code.sh</code></li><li><code>test/</code>，放的是各种自动化、冒烟、UI 测试脚本，这里值得学习和研究下</li><li><code>src/</code>，核心源码，入口是 <code>main.js</code><ul><li>Main Process 的实际调用路径是 <code>main.js -&gt; vs/code/electron-main/main.ts -&gt; vs/code/electron-main/window.ts</code>，在 <code>window.ts</code> 启动了一个 <code>BrowserWindow</code> 加载了 <code>vs/code/electron-browser/workbench/workbench.html</code></li><li>Renderer Process 的实际路径是 <code>vs/code/electron-browser/workbench/workbench.html -&gt; vs/code/electron-browser/workbench/workbench.js</code>，核心逻辑在 <code>workbench.js</code> 中</li><li>而 src 下还有一个核心目录 <code>browser</code>，它是 Web 版本的启动入口</li></ul></li></ul><p>VS Code 的复杂度，有好几块，分别是构建、IoC 机制、RPC 设计、ExtensionHost 环境等，再加上 Electron 本身的各种坑，后续我们可以一一进行探讨。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>在玩转 VS Code 架构设计之前，我们需要先搞清楚代码的大致执行流程，还要学会在遇到问题时调试它的代码，光靠通扫几遍源码你是很难完全理解的。</p><p>VS Code 的使用文档写的非常棒，但是架构和设计文档只能从代码中自己探索，这是可以理解的，VS Code 目前还在高速发展中，内部架构设计调整也十分频繁，而且他们可能倡导的是“代码即文档”，通过一些规范化约束来帮助开发者理解架构设计。</p><p>不过没关系，既然开源了，就自己研究好了。下面我们先看看如何对 VS Code 的各块代码进行有效调试。</p><p>说到调试，有几个基础知识不得不提一提，不解释清楚，很多同学是无法理解为什么在工具上点几下就会进入调试的。</p><h4 id="Node-js-调试"><a href="#Node-js-调试" class="headerlink" title="Node.js 调试"></a>Node.js 调试</h4><p>Electron 的 <code>Main Process</code> 本质就是一个 Node.js 进程，你可以执行如下命令看看 Electron 的 bin 文件内容：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g electron</span><br><span class="line"><span class="keyword">head</span> -n <span class="number">5</span> $(<span class="keyword">where</span> electron | <span class="keyword">head</span> -n <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>打印出来的结果是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> electron = <span class="built_in">require</span>(<span class="string">'./'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proc = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br></pre></td></tr></table></figure><p>对 Node.js 的调试，可以看看我四年前写的 <a href="https://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line/">《NodeJS 的代码调试和性能调优》</a>，时间有点久了，不过调试原理并没有啥变化。</p><blockquote><p>简单来说，就是启动 Node 时增加了一个 <code>--debug-brk</code> 入参（新版是 <code>--inspect-brk</code>），开启一个可供外部断点调试的端口，然后在外部使用各类工具连接端口，发送指令进行调试。</p></blockquote><h4 id="Chrome-调试"><a href="#Chrome-调试" class="headerlink" title="Chrome 调试"></a>Chrome 调试</h4><p>Chromium 在启动的时候有一个可选参数 <code>--remote-debugging-port</code>, 加上这个参数以后，它会开启远程调试模式，如：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Applications/</span>Google\ Chrome.app<span class="regexp">/Contents/</span>MacOS<span class="regexp">/Google\ Chrome -remote-debugging-port=9222</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你的 Chrome 已经启动，上面的命令不会有效果，可以考虑下载一个 Google Chrome Canary</p></blockquote><p>通过 <code>http://127.0.0.1:9222/json</code> 可以看到当前 Chrome 打开了哪些页面，并且它还会把 DevTools 的 ws 地址也展示出来：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">   <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"devtoolsFrontendUrl"</span>: <span class="string">"/devtools/inspector.html?ws=127.0.0.1:9222/devtools/page/3CFC..."</span>,</span><br><span class="line">   <span class="attr">"id"</span>: <span class="string">"3CFC338A39A4CF1F31F0CB499D94C071"</span>,</span><br><span class="line">   <span class="attr">"title"</span>: <span class="string">"新标签页"</span>,</span><br><span class="line">   <span class="attr">"type"</span>: <span class="string">"page"</span>,</span><br><span class="line">   <span class="attr">"url"</span>: <span class="string">"chrome://newtab/"</span>,</span><br><span class="line">   <span class="attr">"webSocketDebuggerUrl"</span>: <span class="string">"ws://127.0.0.1:9222/devtools/page/3CFC..."</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>我们来做一个小小的实验，上面打开了一个 Chrome，并且展示了一个空标签页，我们尝试使用 websocket 连接它，然后控制它：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wsUrl = <span class="string">"ws://127.0.0.1:9222/devtools/page/3CFC..."</span>;</span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(wsUrl);</span><br><span class="line">ws.onmessage = <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data);</span><br><span class="line">ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'closed'</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'opened'</span>);</span><br></pre></td></tr></table></figure><p>随便找个浏览器的控制台执行这段脚本，会看到打印出来了 <code>opened</code>，然后我们尝试让这个 “新标签页” 跳转到我的博客首页，发送几句命令：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启网络功能</span></span><br><span class="line">ws.send(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  "id":1,</span></span><br><span class="line"><span class="string">  "method":"Network.enable"</span></span><br><span class="line"><span class="string">&#125;`</span>)；</span><br><span class="line"><span class="comment">// 跳转页面</span></span><br><span class="line">ws.send(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  "id": 1,</span></span><br><span class="line"><span class="string">  "method": "Page.navigate",</span></span><br><span class="line"><span class="string">  "params": &#123; "url": "https://www.barretlee.com" &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>);</span><br></pre></td></tr></table></figure><p>你会看到，通过命令行打开的 Chrome 的默认页已经自动跳转到了 <code>https://www.barretlee.com</code>，看到这里你应该已经可以理解了，所谓的调试，其实就是通过连接 Chrome 内部的 DevTools 工具，然后利用 RPC 的方式进行通讯，事实上，这里用到的是 <a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">Remote Debugging Protocol</a> 进行的通讯。</p><blockquote><p>大名鼎鼎的 <a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">Puppeteer</a> 就是基于这层协议做的封装。</p></blockquote><p>好了，为了让你理解 VS Code 的调试原理，已经做了很多铺垫了，事实上，在 VS Code 上进行调试的操作是十分简单的，下面就带着你一起演示下。</p><h3 id="软件调试"><a href="#软件调试" class="headerlink" title="软件调试"></a>软件调试</h3><p>使用 VS Code 打开 VS Code 的源码，点开左侧 sidebar 的 Debug Tab，你会看到调试区域存在很多个调试选项：</p><p><img src="/blogimgs/2019/11/01/vscode-debug-panel.png" alt="VSCode Debug Panel"></p><p>这里的所有调试配置，都对应着项目中 <code>.vscode/launch.json</code> 的内容，我之前写过一篇关于 <code>launch.json</code> 的 <a href="https://www.barretlee.com/blog/2019/03/18/debugging-in-vscode-tutorial/">文章</a>，在这里我们又有机会用到了。</p><p>软件的调试分为两个部分，一个是 Main 进程的调试，一个是 Renderer 进程的调试。</p><blockquote><p>开始调试之前，请先把 VS Code Dev 的监听模式打开，项目目录下执行 <code>yarn watch</code></p></blockquote><h4 id="Main-进程调试"><a href="#Main-进程调试" class="headerlink" title="Main 进程调试"></a>Main 进程调试</h4><p>先进入到一个 Main 进程会执行到的代码区域，打一个断点，如 <code>vs/code/electron-main/main.ts:404:0</code>，然后选择 <code>launch.json</code> 中的 <code>Launch VS Code (Main Process)</code> 配置：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">  <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Launch VS Code (Main Process)"</span>,</span><br><span class="line">  <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.sh"</span>,</span><br><span class="line">  <span class="attr">"windows"</span>: &#123;</span><br><span class="line">    <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.bat"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">    <span class="string">"--no-cached-data"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"outFiles"</span>: [</span><br><span class="line">    <span class="string">"$&#123;workspaceFolder&#125;/out/**/*.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动的默认端口是 <code>5875</code>，点击开始调试按钮，或者按下快捷键 <code>F5</code>，便会进入调试模块，在 VS Code 上也有体现：</p><p><img src="/blogimgs/2019/11/01/vscode-node-debugging.png" alt="VSCode Node Debugging"></p><p>可以看到我们打点的位置也已经亮了起来，阻塞了 VS Code Dev 的启动：</p><p><img src="/blogimgs/2019/11/01/vscode-node-deubgging-demo.png" alt="VSCode Node Debugging Demo"></p><p>好了，现在可以开始你的 Main 进程代码探索之旅了。</p><blockquote><p>需要注意，在调试 Main Process 的时候，不要把断点打到 Renderer 进程里去了，否则你永远也进不了断点；也不要打到 Main Process 不会执行的代码区域，这就要求你对 VS Code 的目录结构有一定的了解了，可以参考“初识 VS Code”章节的介绍</p></blockquote><p>另外，再给你留了一道作业题：</p><blockquote><p>尝试使用其他工具，如 node-inspector 或者 Webstorm 调试 Main 进程。</p></blockquote><h4 id="Renderer-进程的调试"><a href="#Renderer-进程的调试" class="headerlink" title="Renderer 进程的调试"></a>Renderer 进程的调试</h4><p>Renderer 进程的调试，本质就是通过外部工具连接 Electron 中 Chromium 打开的一个 DevTools Server，使用 WebSocket 建立连接，然后发送和接受各种指令。</p><p>选择 <code>launch.json</code> 中的 <code>Launch VS Code</code>，它的内容是：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"chrome"</span>,</span><br><span class="line">  <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Launch VS Code"</span>,</span><br><span class="line">  <span class="attr">"windows"</span>: &#123;</span><br><span class="line">    <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.bat"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"osx"</span>: &#123;</span><br><span class="line">    <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.sh"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"linux"</span>: &#123;</span><br><span class="line">    <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.sh"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"timeout"</span>: <span class="number">20000</span>,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"VSCODE_EXTHOST_WILL_SEND_SOCKET"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"breakOnLoad"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"urlFilter"</span>: <span class="string">"*workbench.html*"</span>,</span><br><span class="line">  <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">    <span class="string">"--inspect=5875"</span>,</span><br><span class="line">    <span class="string">"--no-cached-data"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"webRoot"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，开启调试后，找个 Renderer 进程会执行到的代码块进行断点，如 <code>vs/code/workbench/workbench.desktop.main.ts</code>，如果你的 VS Code Dev 已经启动了，可以在 VS Code Dev 的界面中按下 <code>cmd+r</code>，它会自动刷新 Renderer 进程（刷新页面），重新进入你的断点：</p><p><img src="/blogimgs/2019/11/01/vscode-chrome-deubgging.png" alt="VSCode Chrome Debugging"></p><p>怎么样，看到这里，是不是对开发 VS Code 的源码已经有信心了。</p><blockquote><p>需要注意的是，如果你是通过 <code>./script/code.sh</code> 在控制台手动启动的 VS Code Dev，<code>launch.json</code> 中的 <code>Attach to VS Code</code> 是无效的，因为在启动的时候，不会默认添加 –remote-debugging-port 入参</p></blockquote><h3 id="构建脚本调试"><a href="#构建脚本调试" class="headerlink" title="构建脚本调试"></a>构建脚本调试</h3><p>知道了如何对软件本身的代码进行调试，大部分情况下已经够用了，但是如果你在启动 VS Code 的时候失败了，报了个错，或者当你打包 VS Code 的时候，抛出个异常，需要怎么排查问题呢？</p><p>这里，我们可以了解下构建脚本的调试，虽说构建脚本我们可以随时写一句 <code>console.log</code> 打印日志，但是 VS Code 的 <code>build</code> 脚本是非常多，而且每一次的构建都特别漫长，还是更加推荐你使用它提供的构建脚本调试能力进行 Debug，在 <code>launch.json</code> 中有一个 <code>Gulp Build</code> 配置：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">  <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Gulp Build"</span>,</span><br><span class="line">  <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/node_modules/gulp/bin/gulp.js"</span>,</span><br><span class="line">  <span class="attr">"stopOnEntry"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"args"</span>: [</span><br><span class="line">    <span class="string">"hygiene"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个配置启动 gulp，这样就可以对构建脚本进行断点了，由于配置中加了 <code>stopOnEntry</code>，当进入调试的时候，第一行就会断住：</p><p><img src="/blogimgs/2019/11/01/debug-grulp.png" alt="VSCode Gulp Debugging"></p><p>你也可以去掉这个参数，不过需要你在执行 gulp 之前在程序中提前断一个点：</p><p><img src="/blogimgs/2019/11/01/debug-gulp-file.png" alt="VSCode Gulp Debugging"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>好了，VS Code 源码的调试教程就写到这里，希望你读完这篇文章以后，可以自己动手去尝试，很多比较细节的点我没有写全面，所以实践过程中你可能还会遇到一些坑，当你躺平了这些坑，相信你就可以完全理解这些调试的基本原理了。</p><p>后续将带着大家看一看 VS Code 的整体执行链路，其实上次我已经写过一篇类似的 <a href="https://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/">文章</a>了，行文比较粗糙，下次将带着大家一边调试一边看代码和执行链路。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/11/01/vscode-study-02-debugging/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Github 的 Go to Definition 功能实现剖析]]></title>
      <link>http://www.barretlee.com/blog/2019/10/31/github-go-to-definition/</link>
      <guid>http://www.barretlee.com/blog/2019/10/31/github-go-to-definition/</guid>
      <pubDate>Thu Oct 31 2019 23:58:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[Github 的源码阅读已经支持 Go to Definition 了，目前还在 beta 阶段，且需要用户手动开启，仔细研究了下它的实现方式，从逻辑上看是存在 bug 的，整体策略大概是：]]>
      
      </description>
      <content:encoded><![CDATA[<p>Github 的源码阅读已经支持 Go to Definition 了，目前还在 beta 阶段，且需要用户手动开启，仔细研究了下它的实现方式，从逻辑上看是存在 bug 的，整体策略大概是：</p><p><img src="/blogimgs/2019/10/31/go-to-definition.png" alt="Go to Definition"></p><ol><li>仓库进入 Navigation 模式（initialization），Github Server 端对该版本（取 commit hash）的源码进行词法分析，保存关键 token 信息，并记录关键 token 的初始定义位置和被引用的位置；</li><li>用户进入网页，若 initialization 未完成则无效果；否则启动 Navigation 模式；</li><li>探测用户鼠标 hover 事件，当 hover 到 textNode 节点时，取出节点位置，这里用到的是一个新的 API：document.caretRangeFromPoint；</li><li>步骤 3 中拿到的只是 offset，它是个位置数值信息，通过正则 /\w+[!?]?/g 匹配出 hover 到的目标文本，然后将信息发送到 Server，入参包括文本、文件路径、commit hash 和语言类型；</li><li>Server 端返回步骤 1 中生成的 token 元数据，并直接解析成 HTML，前端展示</li></ol><p>这里的 bug 就出现在第 5 步，如果某个变量在两个子作用域中定义，那么 Server 端是无法识别它的 Definition 属于哪个作用域的（我没测试，从理论上讲，应该有这个 bug），另外它 hover 到任何单词都会发送请求，但是后台却只对 function 做了识别，其他类型都是无返回的。</p><p>简单来说，这个 beta 功能可以满足部分场景的需要，但并不能完全覆盖且准确地识别所有类型。真要完整识别，应该只能在浏览器端通过 LSP 协议来做，不过这么做的话，对网络 IO 和本地 CPU 都是一个巨大的挑战，Web 版的 VS Code 会有这个能力，我估计 Github 网页上不会提供。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/10/31/github-go-to-definition/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Google 的 Code Review 实践经验]]></title>
      <link>http://www.barretlee.com/blog/2019/10/30/google-code-review-practice/</link>
      <guid>http://www.barretlee.com/blog/2019/10/30/google-code-review-practice/</guid>
      <pubDate>Wed Oct 30 2019 12:42:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[Google 的 Code Review 目标是不断提高 codebase 的质量，同时要求审阅者在代码的高质量和业务的推进之间做好权衡，两边的极端都不要走，并给出了一些实战经验，下面我总结了下：]]>
      
      </description>
      <content:encoded><![CDATA[<p>Google 的 Code Review 目标是不断提高 codebase 的质量，同时要求审阅者在代码的高质量和业务的推进之间做好权衡，两边的极端都不要走，并给出了一些 <a href="https://google.github.io/eng-practices/review/reviewer/looking-for.html" target="_blank" rel="noopener">实战经验</a>，下面我总结了下：</p><p><strong>1. 设计</strong></p><p>新增的几块代码是否有意义？代码的结构是否合理，应该放在 codebase 里还是抽离成组件？对系统的持续集成是否会造成印象？等等。</p><p><strong>2. 功能</strong></p><p>站在用户的角度和开发者的角度，从功能和代码块上去审阅功能的合理性，除此之外，还要考虑单从代码上看不到的问题，比如并发问题、UI 交互问题、死锁问题等等。</p><p><strong>3. 复杂度</strong></p><p>审查是否存在工程上的过度设计，鼓励解决当下的问题，不要对未来做过多的设计，因为未来（业务）充满了不确定性。</p><p><strong>4. 测试</strong></p><p>除非是紧急上线，一般情况下，都要求提交的代码有单元测试、集成测试和端对端测试，要确保测试用例正确、有意义、有效果。</p><p><strong>5. 命名</strong></p><p>开发者是否给所有的变量都准确命名？一个好的命名不应太长也不可过短，刚好让人看懂的长度最好了。</p><p><strong>6. 注释</strong></p><p>开发者写的注释除了他自己外其他看得懂么？所有的注释是否是有意义的？是否描述清楚了代码是干啥的？有一点需要强调：对于正则以及复杂的逻辑是必须加注释的。</p><p><strong>7. 格式</strong></p><p>这一块我觉得他讲的并不好，格式主要在工具层面通过 lint 来纠正，只不过格式之外会有一些团队的约定，需要人为去判断或者不好工具检测的部分，可以在 Code Review 的时候提出来。</p><p><strong>8. 文档</strong></p><p>相关的 README 或者文档自动生成工具是否补全，废弃的代码、文档是否删除等。</p><p><strong>9. 每一行</strong></p><p>确保每一行都仔细审阅，包括数据文件、自动生成的文件、大的数据结构描述等等，如果代码很难阅读，你应该提前告诉开发者注意这方面的问题，难阅读的代码，对任何人都是一样难阅读的，这种代码应该尽量避免出现。</p><p><strong>10. 上下文</strong></p><p>Code Review 工具一般只会展示 diff 的内容，有的时候，你需要阅读整个文件，以确保开发者的逻辑是有用的，站在系统层面去考虑，这段代码是否会带来复杂度，是否是健康的，等等。</p><p><strong>11. 好的内容</strong></p><p>如果你看到开发者写的内容不错，不要吝啬的赞美和鼓励。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/10/30/google-code-review-practice/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[换一种视角理解 awk 命令]]></title>
      <link>http://www.barretlee.com/blog/2019/10/29/awk/</link>
      <guid>http://www.barretlee.com/blog/2019/10/29/awk/</guid>
      <pubDate>Tue Oct 29 2019 14:49:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[awk 是使用频度非常高的一个超级有用的命令，如果你做过应用的线上运维，想必已经是十分熟悉了，但是对大多数人来说，它仍然是个陌生的东西，即便看过很多次文档，依然记不住它的模样，还是得翻文档、查 Google。下面我就带着你，换一种视角重新理解下 awk。]]>
      
      </description>
      <content:encoded><![CDATA[<p>awk 是使用频度非常高的一个超级有用的命令，如果你做过应用的线上运维，想必已经是十分熟悉了，但是对大多数人来说，它仍然是个陌生的东西，即便看过很多次文档，依然记不住它的模样，还是得翻文档、查 Google。下面我就带着你，换一种视角重新理解 awk。</p><p><img src="/blogimgs/2019/10/29/awk.jpg" alt="AWK"></p><p>它是什么？我觉得它就是一个表单筛选工具，往下看。</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>下面是我截取 <code>cat /etc/passwd</code> 的部分内容，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>保存为 <code>1.txt</code>，然后执行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123; print "No. R1 R3 R4"; count = 0 &#125; $3 &gt; 5 &amp;&amp; $3 &lt; 50 &amp;&amp; $1 !~ /root/ &#123; count += 1; print NR, $1, $3, $4&#125; END &#123; print "total " count " lines" &#125; '</span></span><br></pre></td></tr></table></figure><p>输入的内容是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No. R1 R3 R4</span><br><span class="line">7 man 6 12</span><br><span class="line">8 lp 7 7</span><br><span class="line">9 mail 8 8</span><br><span class="line">10 news 9 9</span><br><span class="line">total 4 lines</span><br></pre></td></tr></table></figure><p>看起来好像很复杂的样子，下面我们进行分解动作，一步一步带你认识 awk 的世界。</p><h3 id="获取表单"><a href="#获取表单" class="headerlink" title="获取表单"></a>获取表单</h3><p>例子里的数据是结构化的，每一行有 7 条数据，使用 <code>:</code> 连接符合并成一行，总共 10 行，所以你看到的就是一个无表头的 10 行 7 列数据，我们可以通过如下命令对表单进行整理：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' &#123; print $1, $2, $3, $4, $5, $6, $7 &#125; '</span></span><br></pre></td></tr></table></figure><p><code>-F</code> 是分隔符标识，默认 awk 命令以空格作为分隔符，在这个例子中，我们需要告诉程序 <code>:</code> 为列分隔符。这条命令执行的结果是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root x 0 0 root /root /bin/bash</span><br><span class="line">daemon x 1 1 daemon /usr/sbin /usr/sbin/nologin</span><br><span class="line">bin x 2 2 bin /bin /usr/sbin/nologin</span><br><span class="line">sys x 3 3 sys /dev /usr/sbin/nologin</span><br><span class="line">sync x 4 65534 sync /bin /bin/sync</span><br><span class="line">games x 5 60 games /usr/games /usr/sbin/nologin</span><br><span class="line">man x 6 12 man /var/cache/man /usr/sbin/nologin</span><br><span class="line">lp x 7 7 lp /var/spool/lpd /usr/sbin/nologin</span><br><span class="line">mail x 8 8 mail /var/mail /usr/sbin/nologin</span><br><span class="line">news x 9 9 news /var/spool/news /usr/sbin/nologin</span><br></pre></td></tr></table></figure><p><code>$0</code> 会打印整行数据，<code>$1</code> 表示第一列数据，同理，我们将七列数据都打印了出来，<code>$1</code> 到 <code>$7</code> 都是 <code>print</code> 函数的入参，事实上，它与这种写法是一个意思：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' &#123; print($1, $2, $3, $4, $5, $6, $7) &#125; '</span></span><br></pre></td></tr></table></figure><h3 id="添加表头"><a href="#添加表头" class="headerlink" title="添加表头"></a>添加表头</h3><p>由于我们提供的数据没有表头，我们给它加上：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123; print("No.", "R1", "R2", "R3", "R4", "R5", "R6", "R7") &#125; &#123; print(NR, $1, $2, $3, $4, $5, $6, $7) &#125; '</span></span><br></pre></td></tr></table></figure><p>在原来的基础上，我们增加了 <code>BEGIN { }</code> 段落，为此我们就给内容提供了表头：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No. R1 R2 R3 R4 R5 R6 R7</span><br><span class="line">1 root x 0 0 root /root /bin/bash</span><br><span class="line">2 daemon x 1 1 daemon /usr/sbin /usr/sbin/nologin</span><br><span class="line">3 bin x 2 2 bin /bin /usr/sbin/nologin</span><br><span class="line">4 sys x 3 3 sys /dev /usr/sbin/nologin</span><br><span class="line">5 sync x 4 65534 sync /bin /bin/sync</span><br><span class="line">6 games x 5 60 games /usr/games /usr/sbin/nologin</span><br><span class="line">7 man x 6 12 man /var/cache/man /usr/sbin/nologin</span><br><span class="line">8 lp x 7 7 lp /var/spool/lpd /usr/sbin/nologin</span><br><span class="line">9 mail x 8 8 mail /var/mail /usr/sbin/nologin</span><br><span class="line">10 news x 9 9 news /var/spool/news /usr/sbin/nologin</span><br></pre></td></tr></table></figure><p><code>NR</code> 是行号的意思，为了让它好看一点，我们使用 <code>printf</code> 函数进行格式化打印：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123; printf("%8s %5s %5s %5s %5s %5s %15s %20s\n", "No.", "R1", "R2", "R3", "R4", "R5", "R6", "R7") &#125; &#123; printf("%5s %8s %5s %5s %5s %5s %15s %20s\n", NR, $1, $2, $3, $4, $5, $6, $7) &#125; '</span></span><br></pre></td></tr></table></figure><p>打印的结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  No.    R1    R2    R3    R4    R5              R6                   R7</span><br><span class="line"> 1     root     x     0     0  root           /root            /bin/bash</span><br><span class="line"> 2   daemon     x     1     1 daemon       /usr/sbin    /usr/sbin/nologin</span><br><span class="line"> 3      bin     x     2     2   bin            /bin    /usr/sbin/nologin</span><br><span class="line"> 4      sys     x     3     3   sys            /dev    /usr/sbin/nologin</span><br><span class="line"> 5     sync     x     4 65534  sync            /bin            /bin/sync</span><br><span class="line"> 6    games     x     5    60 games      /usr/games    /usr/sbin/nologin</span><br><span class="line"> 7      man     x     6    12   man  /var/cache/man    /usr/sbin/nologin</span><br><span class="line"> 8       lp     x     7     7    lp  /var/spool/lpd    /usr/sbin/nologin</span><br><span class="line"> 9     mail     x     8     8  mail       /var/mail    /usr/sbin/nologin</span><br><span class="line">10     news     x     9     9  news /var/spool/news    /usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>怎么样，这个表单看起来就很自然了吧！</p><h3 id="表单筛选"><a href="#表单筛选" class="headerlink" title="表单筛选"></a>表单筛选</h3><p>想象一下，拿到手里的是一个 Excel 表格，我们要对表格进行分析，比如，我要隐藏 R2、R3、R4 这几栏，十分简单，打印的时候不写出来就行了，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123; printf("%8s %5s %5s %15s %20s\n", "No.", "R1", "R5", "R6", "R7") &#125; &#123; printf("%5s %5s %5s %15s %20s\n", NR, $1, $5, $6, $7) &#125; '</span></span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  No.    R1    R5              R6                   R7</span><br><span class="line"> 1  root  root           /root            /bin/bash</span><br><span class="line"> 2 daemon daemon       /usr/sbin    /usr/sbin/nologin</span><br><span class="line"> 3   bin   bin            /bin    /usr/sbin/nologin</span><br><span class="line"> 4   sys   sys            /dev    /usr/sbin/nologin</span><br><span class="line"> 5  sync  sync            /bin            /bin/sync</span><br><span class="line"> 6 games games      /usr/games    /usr/sbin/nologin</span><br><span class="line"> 7   man   man  /var/cache/man    /usr/sbin/nologin</span><br><span class="line"> 8    lp    lp  /var/spool/lpd    /usr/sbin/nologin</span><br><span class="line"> 9  mail  mail       /var/mail    /usr/sbin/nologin</span><br><span class="line">10  news  news /var/spool/news    /usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>再比如，我们想拿到第六列包含 var 的内容，正则过滤下就行了</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' $6 ~ /var/ &#123; printf("%5s %5s %5s %15s %20s\n", NR, $1, $5, $6, $7) &#125; '</span></span><br></pre></td></tr></table></figure><p>执行结果是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 7   man   man  /var/cache/man    /usr/sbin/nologin</span><br><span class="line"> 8    lp    lp  /var/spool/lpd    /usr/sbin/nologin</span><br><span class="line"> 9  mail  mail       /var/mail    /usr/sbin/nologin</span><br><span class="line">10  news  news /var/spool/news    /usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>再来个复杂点的，我们想拿到 R4 范围在 0~5，并且不包含 Root 的数据：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' $4 &gt;= 0 &amp;&amp; $4 &lt;= 5 &amp;&amp; $1 !~ /root/ &#123; printf("%5s %5s %5s %15s %20s\n", NR, $1, $5, $6, $7) &#125; '</span></span><br></pre></td></tr></table></figure><p>筛选结果出来了：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 daemon daemon       /usr/sbin    /usr/sbin/nologin</span><br><span class="line">3   bin   bin            /bin    /usr/sbin/nologin</span><br><span class="line">4   sys   sys            /dev    /usr/sbin/nologin</span><br></pre></td></tr></table></figure><p>相关的筛选功能还有很多，这里就不一一枚举了，上述几个筛选其实也已经可以满足大部分的条件了。</p><h3 id="增加表尾"><a href="#增加表尾" class="headerlink" title="增加表尾"></a>增加表尾</h3><p>我们想统计 R7 包含 <code>nologin</code> 信息的条目数量，展示在表尾，稍微复杂一点，这里会用到一点编程知识：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123; count = 0 &#125; &#123; if ($7 ~ /nologin/)&#123; count = count + 1; &#125; printf("%5s %8s %5s %5s %5s %5s %15s %20s\n", NR, $1, $2, $3, $4, $5, $6, $7) &#125; END &#123; printf("total %s items with nologin", count)&#125;'</span></span><br></pre></td></tr></table></figure><p>看到的结果是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1     root     x     0     0  root           /root            /bin/bash</span><br><span class="line">    2   daemon     x     1     1 daemon       /usr/sbin    /usr/sbin/nologin</span><br><span class="line">    3      bin     x     2     2   bin            /bin    /usr/sbin/nologin</span><br><span class="line">    4      sys     x     3     3   sys            /dev    /usr/sbin/nologin</span><br><span class="line">    5     sync     x     4 65534  sync            /bin            /bin/sync</span><br><span class="line">    6    games     x     5    60 games      /usr/games    /usr/sbin/nologin</span><br><span class="line">    7      man     x     6    12   man  /var/cache/man    /usr/sbin/nologin</span><br><span class="line">    8       lp     x     7     7    lp  /var/spool/lpd    /usr/sbin/nologin</span><br><span class="line">    9     mail     x     8     8  mail       /var/mail    /usr/sbin/nologin</span><br><span class="line">   10     news     x     9     9  news /var/spool/news    /usr/sbin/nologin</span><br><span class="line">total 8 items with nologin</span><br></pre></td></tr></table></figure><p>结尾多了一行，我们来分析下这句命令，总共分为三段：</p><ul><li><code>BEGIN { count = 0 }</code>，声明计数器</li><li><code>{ if ($7 ~ /nologin/){ count = count + 1; } printf(...) }</code>，判断并计数</li><li><code>END { printf(&quot;total %s items with nologin&quot;, count)}</code>，打印结果</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上，揭开了 awk 的面纱以后，你会发现它并没有那么复杂。当然，awk 也远不是上面我们看到的这么简单，它的使用可以变得非常复杂只不过在日常的运维过程中我们用不上而已。</p><p>把 awk 当做表单处理工具来理解，我相信你一定可以轻松记住它的所有命令，就算记不住，以后看到一长串命令也能够很快地理解它。更多资料可以看这个手册：<a href="http://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">The GNU Awk User’s Guide</a>。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/10/29/awk/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Git 约定式提交规范实践]]></title>
      <link>http://www.barretlee.com/blog/2019/10/28/commit-convention/</link>
      <guid>http://www.barretlee.com/blog/2019/10/28/commit-convention/</guid>
      <pubDate>Mon Oct 28 2019 15:14:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p><a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank" rel="noopener">约定式提交规范</a> 提供了一个轻量级的提交历史编写规则，它的内容十分简单：</p><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">type</span>&gt;[<span class="keyword">optional</span> scope]: &lt;description&gt;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">optional</span> body]</span><br><span class="line"></span><br><span class="line">[<span class="keyword">optional</span> footer(s)]</span><br></pre></td></tr></table></figure><p>举个简单的例子：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">feat(config): 允许<span class="built_in"> config </span>对象直接从其他<span class="built_in"> config </span>继承</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: 在<span class="built_in"> config </span>对象中增加 `extends` 字段，用于从其他继承 config</span><br><span class="line"></span><br><span class="line">close issue #23</span><br></pre></td></tr></table></figure><p>在 git commit 时，如果你想进行多行 commit 编辑，可以通过 <code>git commit -a</code> 进入编辑界面；如果是单行，可以直接 <code>git commit -a -m &#39;COMMIT MESSAGE&#39;</code> 完成提交。</p><h3 id="更多的约定"><a href="#更多的约定" class="headerlink" title="更多的约定"></a>更多的约定</h3><p>约定式规范与 <a href="http://semver.org/" target="_blank" rel="noopener">SemVer</a> 的设计是相吻合的，</p><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">PATCH</span> -&gt; <span class="keyword">type</span>(fix)</span><br><span class="line"><span class="type">MINOR</span> -&gt; <span class="keyword">type</span>(feat)</span><br><span class="line"><span class="type">MAJOR</span> -&gt; <span class="type">BREAKING</span> <span class="type">CHNAGE</span></span><br></pre></td></tr></table></figure><p>大部分的提交中，我们都会使用 fix 和 feat 来描述本次修改的类型，当然也包含其他类型，如 <code>chore/docs/reflector/improvement/perf/test/style</code>，值得注意的是：</p><ul><li>一般不用写 <code>body</code> 部分的内容，除非存在 <code>BREAKING CHANGE</code></li><li><code>description</code> 的内容要相当简明扼要，用简单的语句把修改点直接说出来</li><li>一般不建议将多次修改放在一次提交中，尤其是一次半（第二个修改只完成了一部分）的情况</li><li><code>scope</code> 可以是一个文件的地址，如 <code>/lib/utils</code>；也可以是某个功能点 <code>parser</code>，不建议超过两个单词</li></ul><h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><p><strong>合并多次提交</strong></p><p>如果你上次修改的内容存在 bug 或未完成，本次提交的内容与上次几乎一样，建议使用 <code>git rebase -i</code> 进行提交的合并，如</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~<span class="number">3</span> # 展示最近 <span class="number">3</span> 次修改</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">pick <span class="number">0291959</span> chore<span class="comment">(blog)</span>: 清理无关项</span><br><span class="line">pick <span class="number">1</span>ef<span class="number">8</span>f<span class="number">31</span> chore<span class="comment">(blog)</span>: 清理无关项</span><br><span class="line">pick <span class="number">36</span>a<span class="number">91</span>db fix<span class="comment">(post)</span>: 格式化 post 的 meta 数据格式,增加 --- 开始符</span><br></pre></td></tr></table></figure><p>可以将第二行的 <code>pick</code> 修改为 <code>squash</code>，表示保留 commit 但将本次修改合并到上次，相关的操作可以看 <a href="https://www.barretlee.com/blog/2018/11/26/git-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/">这篇文章</a>。</p><p><strong>关闭 ISSUE</strong></p><p>在 github/gitlab 中，如果 commit message 中带有 <code>Fix #23</code> 诸如此类的信息，当 commit 被 push 到 repo 后，会自动关闭编号为 23 的 issue。</p><p><strong>自动生成 CHANGELOG</strong></p><p>在写日报或者周报，或者在项目发版时，我们可以很轻松地从提交日志中看到自己或者团队干了些什么事情：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> git-changelog=<span class="string">'git log --oneline --decorate'</span>;</span><br></pre></td></tr></table></figure><p>当然也可以使用开源的工程自动生成结构化更强的 CHANGELOG 日志，如 <a href="https://github.com/CookPete/auto-changelog" target="_blank" rel="noopener">auto-changelog</a>，它提供了可自定义的 CHANGELOG 模板。</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>约定如果没有工具来辅助和约束，大概率就成了一纸空文，毫无意义。在项目实战中，我们可以做如下配置让项目成员强制进行约定式提交。</p><p><strong>1. 安装工具</strong></p><p>推荐使用 <code>@commitlint/cli</code> 进行检测，安装方式：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install @commitlint/cli --save-dev</span><br></pre></td></tr></table></figure><p><strong>2. 配置约定</strong></p><p>在 <code>@commitlint</code> 工具包中有一个规则比较强的检测规范：<code>@commitlint/config-conventional</code>，也安装到项目中：</p><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install @commitlint/config-conventional --save-dev</span><br></pre></td></tr></table></figure><p>安装完成后，需要显式地配置，在项目中增加 <code>commitlint.config.js</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">  extends: [</span><br><span class="line">    <span class="string">'@commitlint/config-conventional'</span></span><br><span class="line">  ] </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>config-conventional</code> 中允许类型有 <code>build/chore/ci/docs/feat/fix/perf/refactor/revert/style/test</code>。</p><p><strong>3. 提交时执行检查</strong></p><p>推荐使用 <code>husky</code> 这个工具，它会帮助我们自动配置 commit hooks，只需在项目中添加 <code>.huskyrc.json</code> 文件：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">    <span class="attr">"pre-commit"</span>: <span class="string">"node ./node_modules/@commitlint/cli/lib/cli.js -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以直接在 package.json 中配置 <code>husky</code> 字段，具体可以查看 <a href="https://github.com/typicode/husky" target="_blank" rel="noopener">文档</a>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>整洁的提交记录并不仅仅意味着开发者自动生成 CHANGELOG，遵守约定可以给项目沉淀一个结构化的提交历史，再加上一些 emoji，生成出来的文档简直就是一篇生动的项目发展史，它有助于我们向公众传达变化的性质，同时对继续集成也会带来一定的好处，比如我们可以根据 type 触发不同的构建和部署流程。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/10/28/commit-convention/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[本博客的配置和发布]]></title>
      <link>http://www.barretlee.com/blog/2019/10/27/blog-config/</link>
      <guid>http://www.barretlee.com/blog/2019/10/27/blog-config/</guid>
      <pubDate>Sun Oct 27 2019 23:54:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>分享下我个人博客（<a href="https://www.barretlee.com">https://www.barretlee.com</a>）的配置和发布：</p><h3 id="1-域名"><a href="#1-域名" class="headerlink" title="1. 域名"></a>1. 域名</h3><p>在 DNSPod 上配置的域名，默认解析到 coding pages，国外解析到 github pages，DNSPod 支持 D 监控，当域名不可用时会邮件警报。</p><p>coding 支持绑定多个域名，也支持给所有绑定的域名自动配置证书，github 只能绑定一个域名，这就会导致 <a href="http://www.barretlee.com">www.barretlee.com</a> 和 barretlee.com 只能有一个是 https，比较坑，貌似 Google 的 DNS 解析服务能够解决这个问题，国内的似乎都不行。</p><h3 id="2-开发"><a href="#2-开发" class="headerlink" title="2. 开发"></a>2. 开发</h3><p>使用 hexo 构建，由于文章比较多，超过 300 篇，构建时长约 6min，很慢；hexo 支持多 git 仓库部署，我配置了 coding 和 github 两个。</p><p>使用了不少 hexo 的插件，但是很多都不满足需求，不满足需求的插件都重新改写了。平时使用改写的 hexo-admin 在本地编辑内容。</p><p><img src="/blogimgs/2019/10/27/blog-config-admin.png" alt="blog config admin"></p><h3 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h3><p>以前每次都是本地编辑文章，然后构建发布，发现错别字，又回到本地编辑、构建、发布，体验十分差，所以近两年都懒得写文章了，宁愿发长微博。</p><p>本周末折腾了一番，接入了 travis-ci，发现还挺好用，只是配置的时候需要注意点 git 仓库权限问题，可以参考 <a href="https://github.com/barretlee/blog/blob/master/.travis.yml" target="_blank" rel="noopener">https://github.com/barretlee/blog/blob/master/.travis.yml</a> 解决问题，后续写文章应该会直接走 github 网页新建文件。</p><p><img src="/blogimgs/2019/10/27/blog-config-travis.png" alt="blog config travis"></p><h3 id="4-评论"><a href="#4-评论" class="headerlink" title="4. 评论"></a>4. 评论</h3><p>从多说到畅言到 github issue，估计不会再继续折腾了，看了两个开源的 github issue 评论组件，gitment 和 gitalk ，这两个工具都有点像半成品，感觉还有很大的优化空间，由于 gitalk UI 稍微看得舒服点，将就着用了，效果如图四。历史评论就懒得迁移了。</p><p><img src="/blogimgs/2019/10/27/blog-config-comment.png" alt="blog config comment"></p><p>周末把博客 UI 的部分细节做了调整，估计后续三五年都不会再折腾博客设计了。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/10/27/blog-config/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[让 VSCode 在本地 Run 起来]]></title>
      <link>http://www.barretlee.com/blog/2019/10/23/vscode-study-01-start/</link>
      <guid>http://www.barretlee.com/blog/2019/10/23/vscode-study-01-start/</guid>
      <pubDate>Wed Oct 23 2019 19:38:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>Visual Studio Code 是微软推出的一款轻量级编辑器，与它一起在市场争锋的相似软件还有 Atom 和 Sublime Text，面世第二年的它只占据 7% 左右的市场，后来在短短三年时间雄踞了半壁江山，不可谓不哇塞。</p><p><img src="/blogimgs/2019/10/23/vscode-snapshot.png" alt="vscode-snapshot"></p><p>发育如此强势的软件，背后到底是如何设计的，未来一段时间，我将带着你一点一点拨开她的面纱，再撩开她的裙摆。</p><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>Visual Studio Code 简称 VSCode，需要注意的是，平时我们使用的 VSCode 那是产品，而下面我们要介绍的是源码，产品是源码的构建结果；源码使用的 <a href="https://github.com/microsoft/vscode/blob/master/LICENSE.txt" target="_blank" rel="noopener">MIT License</a>，而产品使用的是这个 <a href="https://code.visualstudio.com/License" target="_blank" rel="noopener">MICROSOFT SOFTWARE LICENSE TERMS</a>，如果你想把 VSCode 用于商用，建议从源码构建出新的产品，而不是直接使用人家官网上提供下载链接的 VSCode Product。</p><ul><li>官网地址是 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></li><li>源码在这里：<a href="https://github.com/microsoft/vscode" target="_blank" rel="noopener">https://github.com/microsoft/vscode</a>。</li></ul><p>我们先把源码 down 下来：</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">--depth</span> <span class="number">1</span> https://github.com/microsoft/vscode.git</span><br></pre></td></tr></table></figure><p>由于 VSCode 项目过于活跃，提交量非常庞大，到目前为止，已经有 <code>56,092</code> 次提交了，建议在下载源码的时候加了一句 <code>--depth 1</code>，意思就是只现在最近一次 commit 的代码。</p><p>30s 后……71M，不慢。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>在安装依赖之前，我们不妨稍微分析下 VSCode 的项目结构，</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) tree -L 1</span><br><span class="line">.</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── ThirdPartyNotices.txt</span><br><span class="line">├── azure-pipelines.yml</span><br><span class="line">├── build/</span><br><span class="line">├── cglicenses.json</span><br><span class="line">├── cgmanifest.json</span><br><span class="line">├── extensions/</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── package.json</span><br><span class="line">├── product.json</span><br><span class="line">├── remote/</span><br><span class="line">├── resources/</span><br><span class="line">├── scripts/</span><br><span class="line">├── src/</span><br><span class="line">├── <span class="built_in">test</span>/</span><br><span class="line">├── tsfmt.json</span><br><span class="line">├── tslint.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>未来我们需要重点关注的是 <code>src/</code> 和 <code>extensions/</code> 两个目录，前者放的是 VSCode 的核心源码，后者放的是 VSCode 的内置插件。</p><p>眼神再晃动一下，应该还会看到几个熟悉的关键词，<code>build/</code>,<code>gulpfile.js</code>,<code>package.json</code>,<code>tslint.json</code> 和 <code>yarn.lock</code>，由此，我们基本可以断定，这个仓库是一个用 TypeScript 开发，用 yarn 管理依赖，用 gulp 进行打包的 Node.js 项目，事实上她也是一个 <a href="https://electronjs.org/" target="_blank" rel="noopener">Electron</a> 项目。</p><p>好了，目录就看到这里，接着开始安装漫长的依赖安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) yarn</span><br></pre></td></tr></table></figure><p>执行 yarn 后，VSCode 会干三件事情：</p><ul><li>preinstall 脚本中对 yarn 的版本做判断<ul><li>要求必须 &gt;=1.10.1</li><li>并且只允许使用 yarn 来安装依赖，npm 安装会弹个错误</li></ul></li><li>安装 package.json 中描述的各个依赖<ul><li>很多依赖都需要重新编译，而编译过程经常会失败</li><li>失败了怎么办？看错误提示，如果流程没中断，就让它一直跑下去</li><li>一直卡着，好像不跑了怎么办？<code>ctrl-c</code> 终止进程后重新执行 <code>yarn</code></li></ul></li><li>postinstall 挨个安装 build/remote/test/extensions 等目录中的依赖<ul><li>extension 的安装比较特殊，安装的过程中又会执行 <code>updateGrammar</code> 脚本</li></ul></li></ul><p>整个安装过程十分的慢，可以考虑泡杯咖啡打开电视剧……</p><p>执行了 yarn 整个安装并没有结束，剩下几步 VSCode 会在你执行 gulp 相关脚本的时候做检测，倘若资源不存在便会安装，由于很多资源都在墙外，我们还是分解下动作，分步手动下载：</p><p><strong>1. 把 Electron 安装下来：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) yarn electron</span><br></pre></td></tr></table></figure><p>如果下载太慢，建议在命令行开下代理：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) proxychains4 yarn electron</span><br></pre></td></tr></table></figure><p>这里附加一个小插曲，</p><blockquote><p>安装到半途时更换了下代理，应该是 gulp-vinyl-zip 这个包处理 buffer 异常，导致下次下载断点续传 buffer 位置对不上，然后每次执行 yarn electron 就直接退出进程，应该是个 bug；解决办法是，在这个包的 <code>open()</code> 方法里打个 log，把 path 打印出来，然后把打印出来的资源删掉就行了。</p></blockquote><p>一小时后……</p><p>我已经不能忍了，电视剧都看了一集了，还是没下载完，其实 <code>electron-v6.0.12-darwin-x64</code> 这个文件只有 66.2M。</p><p>为了完成 electron 的安装，不得不附加第二个插曲，</p><blockquote><p>还是得翻源码解决问题：之前可以通过全局配置 ELECTRON_MIRROR 的地址来选择 Electron 下载源，而最新版 VSCode 的 Electron 是直接从 github 上下载的，从 gulp-atom-electron 这个包的源码里断点找到了 asset 和 assetPath，手动将 asset 下载下来后放到 assetPath，解决了问题。</p></blockquote><p><strong>2. 把内置的几个依赖插件安装下来：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) yarn download-builtin-extensions</span><br></pre></td></tr></table></figure><p>历时差不多一个小时，终于把依赖下载完成了，这是我安装依赖花的时间最长的一次，家里的网络还是比不上厂里自带翻墙功能的网络，衰……</p><h3 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h3><p>由于启动一次构建花费的时间太长，1~5min 不等（看机器性能和人品），所以我建议你使用 <code>yarn watch</code> 来构建，它会完成一次构建并监听文件的变化，后续不用重新构建。</p><p>构建完成以后，就可以执行命令打开 VSCode 的界面了，不过在打开之前，我意外地在 package.json 的 scripts 中发现，VSCode 竟然已经有 Web 版本了！！！</p><p><img src="/blogimgs/2019/10/23/vscode-web.png" alt="VSCode Web"></p><p>这比我之前的预期要早了很多，很早就听说他们内部团队在搞 Web 版本了，没想到这么快就要面世了。社区上有一个基于 VSCode 搞的 Web 版，叫 <a href="https://github.com/cdr/code-server" target="_blank" rel="noopener">Code-Server</a>，Star 量有好几万，估计官方的 Web 版出来以后，code-server 就要凉凉了。</p><p>哦，把 web 版本跑起来的方式是：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gulp watch 完成后执行</span></span><br><span class="line">➜  vscode (master) yarn web</span><br></pre></td></tr></table></figure><p>会自动弹开一个地址：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>，目前 Web 版的功能还不完备，比如插件部分就没有适配，应该还在研发状态，连 inside 版本都没进。这也算是我写这个教程的第一个意外惊喜吧，看来我得重新研究下 VSCode 的源码了。</p><p>执行如下脚本，可以打开 VSCode 的客户端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) ./scripts/code.sh</span><br></pre></td></tr></table></figure><p>然后你就可以看到这样的界面了：</p><p><img src="/blogimgs/2019/10/23/vscode-client.png" alt="VSCode Client"></p><p>如果你是 windows 系统，执行的脚本应该是 <code>./script/code.bat</code>。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>好了，本文的扫盲就到这里。</p><p>本文主要通过傻瓜式地教学，给大家演示了下，如何将源码变成我们熟悉的 VSCode 客户端，相信同学们在动手的过程中还会遇到各种依赖安装问题，不要灰心，实在不行就 <code>rm -rf node_modules</code>，然后重试。</p><p>下回再给大家讲述 <a href="https://www.barretlee.com/blog/2019/11/01/vscode-study-02-debugging/">如何开发和调试 VSCode 的源码</a>。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/10/23/vscode-study-01-start/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[VSCode 是怎么运行起来的？]]></title>
      <link>http://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/</link>
      <guid>http://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/</guid>
      <pubDate>Sat Aug 03 2019 23:52:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>之前有基于 VSCode 做二次开发的经验，约摸全投入持续了 5 个多月，开发了一个 <a href="https://isv.taobao.com/ide" target="_blank" rel="noopener">Editor</a>，算是超级魔改吧，虽然保留了 VSCode 的样子，但是整个板块都有比较大的调整，新增了 Webview 预览面板、Devtool 调试工具、顶部控制区、插件市场等等。</p><p>当时由于需求的实现不需要了解全部的 VSCode 源码，但是也把大部分的源码啃得差不多了，包括：</p><ul><li>整个项目的工程部分，包括项目结构、软件构建、插件构建、持续集成等等</li><li>Workbench 部分的所有逻辑，整个窗体 UI 部分的实现</li><li>插件的实现，插件市场的逻辑，当时单独做了一个新的插件市场体系，插件的下载在自己的服务器管理</li><li>Language Service Protocol 的基本原理</li></ul><p>但是也有很多内容没有掌握，应该说没有太多兴趣和时间了解，包括：</p><ul><li>功能模块的测试和 UI 自动化测试</li><li>CommandRegistry 的内部机制，对应的是 IPCServer 的交互逻辑</li><li>IoC 实现的详细逻辑</li><li>SharedProcess 的基础逻辑</li><li>ExtensionHost 的运行机制</li></ul><p>这两天突然来了兴致，把之前没了解的部分源码通读了一遍，当然，仍然有一些疑惑，也仍然有一些不感兴趣的部分，后续空了会有更多的梳理，下面先贴上这两天的阅读笔记。其实我应该画图来帮助读者理解，不过以下主要是个人笔记，就懒得整理了，感兴趣的读者将就着看。</p><blockquote><p>阅读的版本是 <code>v1.37.0</code>，是目前 VSCode 源码仓库 master 分支最新的代码。</p></blockquote><h3 id="InstantiationService"><a href="#InstantiationService" class="headerlink" title="InstantiationService"></a>InstantiationService</h3><p>基本就是 IoC 的实现原理，以及 Service 的全局管理机制。</p><h4 id="服务注册为可被使用的-Decorator"><a href="#服务注册为可被使用的-Decorator" class="headerlink" title="服务注册为可被使用的 Decorator"></a>服务注册为可被使用的 Decorator</h4><p>提供了一个泛型装饰器 <code>createDecorator</code>，入参是 ServiceName 和 IService，后者是泛型入参：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDecorator</span>&lt;<span class="title">IService</span>&gt;(<span class="params">'service'</span>): <span class="title">ServiceIdentifier</span>&lt;<span class="title">IService</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>内部对 <code>service</code> 的实际处理是：</p><ul><li>记录，下次请求，若存在直接从缓存送出</li><li>记录的方式是：生成一个装饰器，装饰器的作用只判断入参是否是一个 <code>parameter</code>，意思是在类中 <code>method</code> 不允许被它装饰；并将装饰器的 toString 函数置为 <code>service</code> 这个 String</li></ul><p>返回的 <code>ServiceIdentifier</code>，格式为：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ServiceIdentifier&lt;T&gt; &#123;</span><br><span class="line">    (...args: <span class="built_in">any</span>[]): <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">type</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局服务管理"><a href="#全局服务管理" class="headerlink" title="全局服务管理"></a>全局服务管理</h4><ul><li>注册一个管理服务的容器 <code>ServiceCollection</code>，它是一个 Map 类型，储存格式为：<code>&lt;ServiceIdentifier, instanceOrDescriptor&gt;[]</code></li><li>然后将服务容器挂在到全局 <code>instantiationService</code> 服务上，实际上是挂在 <code>instantiationService</code> 的私有成员变量 <code>_services</code> 上</li><li>同时也通过 <code>this._services.set(IInstantiationService, this)</code> 把自己装进了服务容器</li></ul><h4 id="服务的调用"><a href="#服务的调用" class="headerlink" title="服务的调用"></a>服务的调用</h4><ul><li>提供了一个 <code>Trace</code> 方法，记录了每次调用的耗时</li><li><strong>此处看的比较粗糙，InstantiationService.invokeFunction</strong>，通过分析 Service 的依赖，把所有的依赖项目都加载进来</li><li>其中考虑到了循环依赖的问题，直接报错，检测方式是递归查询深度超过 100</li><li>最终通过 <code>IdleValue</code> 类返回了一个 Proxy 对象，只有真正用到的时候才执行返回服务实例</li></ul><h3 id="入口分析"><a href="#入口分析" class="headerlink" title="入口分析"></a>入口分析</h3><p>看看 VSCode 在启动前和启动时都做了哪些事情。</p><h4 id="Code-Application-启动之前"><a href="#Code-Application-启动之前" class="headerlink" title="Code Application 启动之前"></a>Code Application 启动之前</h4><p>VSCode 的入口启动文件是 <code>./out/main.js</code>，对应源文件目录是 <code>./src/vs/main.ts</code>。</p><ul><li><code>vs/base/common/performance</code>，通过数组记录，每两项为一个数据单元，<code>[name, timestamp, ...]</code>，兼容 amd/cmd</li><li><code>vs/base/node/languagePacks</code>，将大量 fs 操作 Promise 化后，提供一个查、写 <code>NLSConfiguration</code> 的方法，兼容 amd/cmd</li><li><code>./bootstrap</code><ul><li><code>injectNodeModuleLookupPath</code>，注入一个 node_modules 的查询路径</li><li><code>enableASARSupport</code>，同上，注入 <code>.asar</code> 路径</li><li><code>uriFromPath</code>，一个兼容 win/mac 的将 path 路径转换成磁盘 uri 的方法</li></ul></li><li>AMD 方式加载入口文件<ul><li><code>./bootstrap-amd</code><ul><li>AMD Loader 配置，<code>github:Microsoft/vscode-loader</code>,</li><li>将 Electron 的 fs 替换成 Node 原生的 fs</li></ul></li><li><code>vs/code/electron-main/main</code><ul><li><code>main</code><ul><li><code>setUnexpectedErrorHandler</code>，避免 Electron 底层报错，上层进行劫持</li><li><code>validatePaths</code> 入参验证</li></ul></li><li><code>startup -&gt; createServices,doStartup</code><ul><li>初始化一个日志服务，<code>bufferLogService</code></li><li>初始化两个重要的服务：<code>instantiationService, instanceEnvironment</code><ul><li>通过 <code>ServiceCollection</code> 记录所有注册的服务，它是一个单纯的 Map，记录的是 <code>&lt;ServiceIdentifier, instanceOrDescriptor&gt;[]</code></li><li>初始化的服务包括：<code>environmentService/logService/configurationService/lifecycleService/stateService/requestService/themeMainService/signService</code></li><li>将 <code>ServiceCollection</code> 挂载到 <code>instantiationService</code>，作为 <code>_services</code> 私有成员</li><li>同时将 <code>instantiationService</code> 挂在到 <code>_services</code> 私有成员上，相当于依然使用 <code>ServiceCollection</code> 管理</li></ul></li><li>完成 <code>environmentService/configurationService/stateService</code> 的初始化</li><li>初始化 <code>mainIpcServer</code>，并连接 <code>sharedIpcServer</code><ul><li>创建一个 <code>mainIpcServer</code>，入参是 <code>environmentService</code> 中记录的 <code>mainIPCHandle</code> 地址</li><li>如果创建失败，非 <code>EADDRINUSE</code> 错误，检查是否已经存在了一个 IPCHandler，如果存在则直接连接，连接失败会重试 1 次</li></ul></li><li>初始化 <strong>CodeApplication</strong>，将 mainIpcServer 和 instanceEnvironment 作为依赖服务挂载上去</li><li>调用 CodeApplication 的 <code>startup</code> 方法启动</li></ul></li><li>过程中如果有报错，则直接退出</li></ul></li></ul></li></ul><h4 id="Code-Application-启动"><a href="#Code-Application-启动" class="headerlink" title="Code Application 启动"></a>Code Application 启动</h4><p>入口文件是 <code>./src/vs/code/electron-main/app.ts</code>，对应的类为 <code>CodeApplication</code>，实例化的时候做了两件事情</p><ul><li>注册一些与 Electron 相关的事件，大多都是禁用一些底层、涉及安全或影响 VSCode 上层交互的事件</li><li>执行 <code>startup</code> 启动<ul><li>启动一个 <code>ElectronIPCServer</code><ul><li>通过 <code>ipcMain</code> 监听 <code>ipc:hello</code> 事件，通过 <code>webContents.id</code> 标记 Client 身份</li><li>每次有一个新的 Client 进来都开始监听 <code>ipc:message</code> 和 <code>ipc:disconnect</code> 事件</li></ul></li><li>获取 MachineId（其实就是 Mac Address 的 hash 处理，降级方案是 uuid），启动一个 <code>SharedProcess</code><ul><li>创建一个不展示（show: false）的 <code>BrowserWindow</code>，启用了 <code>nodeIntegration</code></li><li>加载 <code>vs/code/electron-browser/sharedProcess/sharedProcess.html?config=${config}</code>，通过 url 传参</li><li>新 BrowserWindow 的 ipcRenderer 与 ipcMain 进行三次握手<ul><li>ipcMain 将 <code>sharedIPCHandle</code> 的值传递给 <code>SharedProcess</code></li><li><code>SharedProcess</code> 创建一个 IPCServer</li><li>通过一个新的 CollectionService 生成服务容器，将各种服务通过新注册的 ipc channel 对接到 <code>IPCServer</code></li></ul></li><li><code>MainProcess</code> 连接到 <code>SharedProcess</code> 的 IPCServer</li></ul></li><li>将 Application 的附加 Service 作为 childService 添加到全局 <code>CollectionService</code> 容器</li><li><strong>这里没看太懂</strong>，如果存在 <code>driverHandle</code>，则新建一个 Dirver 的 IPCServer</li><li><strong>这里没看太懂</strong>，注入了一个 <code>ProxyAuth</code> 模块，不知道哪里会用到，内容很简单，就是一个输入账号密码的 <code>BrowserWindow</code> 弹窗</li><li>然后调用 <code>openFirstWindow</code> 打开 VSCode 主界面<ul><li>注册了主进程 IPC 服务：<code>launchService</code></li><li>注册了 Electron IPC 服务：<code>updateChannel/issueChannel/workspaceChannel/windowsChannel/menubarChannel/urlChannel/storageChannel</code> 等</li><li>通过 <code>windowsMainService(windowManager)</code> 打开界面</li></ul></li></ul></li></ul><h3 id="MainIpcServer"><a href="#MainIpcServer" class="headerlink" title="MainIpcServer"></a>MainIpcServer</h3><p>IPCServer 的大致原理，细节非常多，下面只是列了提纲，主要是实现了一套序列化和反序列化的协议，以及 <code>call</code> 调用和 <code>listen</code> 监听的两大逻辑。</p><h4 id="创建-Server"><a href="#创建-Server" class="headerlink" title="创建 Server"></a>创建 Server</h4><ul><li>建立 <code>net server</code>，通过 <code>mainIPCHandle</code> 文件句柄进行监听</li><li>基于 <code>netSocket</code> 封装了 <code>NodeSocket</code>，并绑定了通讯协议 <code>Protocol</code></li><li>创建失败，说明 socket 已经存在，直接连接 Server</li></ul><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">/-------------------------------|<span class="string">------\</span></span><br><span class="line">|<span class="string">             HEADER            </span>|<span class="string">      </span>|</span><br><span class="line">|<span class="string">-------------------------------</span>|<span class="string"> DATA </span>|</span><br><span class="line">|<span class="string"> TYPE </span>|<span class="string"> ID </span>|<span class="string"> ACK </span>|<span class="string"> DATA_LENGTH </span>|<span class="string">      </span>|</span><br><span class="line">\-------------------------------|<span class="string">------/</span></span><br></pre></td></tr></table></figure><h4 id="连接-Server"><a href="#连接-Server" class="headerlink" title="连接 Server"></a>连接 Server</h4><ul><li>连接到 <code>net socket</code> 后，将 <code>netSocket</code> 同上包装两层，<code>NodeSocket + Protocol</code></li><li>指定 <code>ctx</code> 为 <code>main</code>，创建 <code>IPCClient</code>，<code>IPCClient</code> 既是一个 <code>client</code> 也是一个 <code>server</code>，共享一个 socket，通过 Protocol 协议进行通讯<ul><li>创建 <code>ChannelClient</code>，维护一个通讯的 handlers 管理器<ul><li>发起一个远程命令执行请求，将 <code>requestId</code> 和 <code>responseHandler</code> 写入管理器，通过 <code>protocal.send</code> 将请求发出</li><li>监听 <code>protocal.onMessage</code>，通过 <code>requestId</code> 匹配 <code>responseHandler</code> 处理结果</li></ul></li><li>创建 <code>ChannelServer</code>，指定 ctx 为 <code>main</code>（写入 ctx 的值）<ul><li>通过 <code>onRawMessage</code> 监听消息，解析 header 和 body 后，选择对应的 <code>channel</code>，执行 <code>channel.call</code>，执行结果通过 <code>protocal.send</code> 返回</li></ul></li></ul></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上的分析过程，对读者的作用可能并不大，主要是逻辑过于冗长，防止自己读着读着开始迷失，把觉得比较核心的逻辑记录了下来。</p><p>如果读者想了解 VSCode 的全盘代码，有几处是必须全部理解的：</p><ol><li>InstantiationService 设计</li><li>IPC Protocol 设计</li><li>ExtensionHost 设计</li><li>Workbench Layout 设计</li><li>VSCode 的打包机制</li><li>Electron 的几乎所有 API</li></ol><p>后续空闲，我还会结合单测和自动化测试，熟悉 VSCode 整体架构，等有了内容再来分享。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[两个月减 10kg，聊聊这件事]]></title>
      <link>http://www.barretlee.com/blog/2019/07/28/my-way-to-lose-weight/</link>
      <guid>http://www.barretlee.com/blog/2019/07/28/my-way-to-lose-weight/</guid>
      <pubDate>Sun Jul 28 2019 00:16:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>还记得刚进大学的时候也就 120 斤，那会儿还不到 18 岁，身体处于自然增长阶段，可能与生活不规律有点关系吧，四年下来，增重也有 25 斤，一米七四的个头，倒也显得还好，不胖不瘦。</p><p>毕业的随后四年里，依旧保持着极度不良好的生活作息和饮食习惯，体重一路飙升到 167 斤，肚子和脸蛋都开始圆了起来，因此也有了我常年使用的圆咕噜嘟的头像。</p><p>说起 <a href="/blogimgs/avatar.png">我的头像</a>，大概是三年多前，淘宝绘画兴趣小组的一次绘画课程中，我作为模特，同事亚城帮我绘制的，其实是个半成品，很多细节还没有处理完（那堂课只教这么多，囧），不过因为画得实在是贴切，就求了版权，拿了过来。当时的脸并没有画中那么胖，毕竟卡通人物的绘制都会适当加点夸张手法，<strong>但随着时间的推移，脸型越来越接近这张图像……</strong></p><h3 id="一个念头"><a href="#一个念头" class="headerlink" title="一个念头"></a>一个念头</h3><p>估计是因为大块的肥肉藏在了肚子和内脏里，165+ 的体重倒也没有显得特别胖，可带来的各种问题就多了，</p><ul><li>首先是身体上的问题，经常这儿有点疼，那儿有点痛，血压偏高，稍微运动心跳特别快，胡吃海喝，也特别容易油腻；</li><li>更麻烦的是心理上的问题，<strong>整个人就跟得了懒癌一样</strong>，周末不想动，能不走路的不走路，能不起身的不起身，由于这种心态，很多事情也会拖拖拉拉，感觉整个人都在与内心仅剩的那点斗志抗争。</li></ul><p>对于一个胖子而言，三天两头就会蹦出减肥的念头。但是，你应该能懂的，什么节食啊、健身啊，那都是三天打鱼两天晒网，哦，不，应该是三十天晒网。少吃东西带来的饥饿感，以及健身的痛苦感，让我无数次地轻松说服自己，“别减啦！”，每次说服都那么的管用……</p><p>每每看见身边有人减肥成功都赞叹不已，心中也会不禁感叹，“此人必是个狠角色！”，而把竖起的大拇指收回的那一瞬间，减肥的念头也便跟着一起散去了。毕竟，身上掉几十斤肉是我连想都不敢想的事情，那该是多大的痛苦呀！直到参加了上次团队安排的 <a href="/blog/2019/05/29/traveling-in-the-desert/">内蒙古沙漠之旅</a> ……</p><p>在沙漠徒步闲聊的时候，了解到身边有一个小伙伴，最近正在减肥，而且效果十分明显，已经掉了 30 斤了，我问他，你每天都去健身运动么？他说，一周也就一两回，不过吃草倒是吃了好几个月了。看着他在沙漠中只身穿行毫不喘气的身影，再看看一身装备的自己，却还像条狼狈的胖犬，耷拉着舌头，大口地呼吸着炙热的空气，心想，“要不咱也瘦一回试试？”</p><p>团建结束第二天，发了一条朋友圈，立下了一个 Flag，目标瘦身 10kg。与往常不一样的是，执行时间不是从明天开始，而是<strong>「今天」</strong>。</p><h3 id="两个月，10kg"><a href="#两个月，10kg" class="headerlink" title="两个月，10kg"></a>两个月，10kg</h3><p>那段时间的体重在 163~167 之间波动，权且就把 165 当做了起点，目标瞄准 145，回到离开校园时的水位。</p><p>减肥这件事情，倒不是一点经验都没有，曾几何时也是跟着身边的胖子们一起减过的，只不过没能坚持下去，这一次权且把自己的身体当作试验品，一点一点的尝试之前试过的、听过的、看过的一些方子，慢慢找到自己比较能接受的减肥方案。</p><h4 id="阻力"><a href="#阻力" class="headerlink" title="阻力"></a>阻力</h4><p>减肥的时候有三件事情绝不能在我身上发生，否则大概率坚持不下去，估计大部分胖子都是如此：</p><p><strong>1、不能饿着</strong></p><p>饥饿带来的痛苦感，加上美食带来的诱惑，绝对可以摧毁一个胖子减肥的决心，所以饿肯定是不行的，当然我也尝试过保持饥饿，结果就是一天下来整个人昏昏沉沉的，不仅办事效率下去了，体重的变化还不明显，最重要的是，这个法子没法在第二天坚持下去，因为实在是坚持不下去=。 =</p><p><strong>2、不能运动太多</strong></p><p>强运动是一件特别不靠谱的事情，内心触动的时候能够坚持一两天，等到意志略微消沉断了一天，那第二天也没便啥心思运动了，往后几天也因为第二天的不坚持直接破罐子破摔了……另外，如果不控制饮食，即便连续运动一两周效果也不会明显，最后剩下的也只有绝望和放弃了。</p><p><strong>3、不能准备太多</strong></p><p>前期减肥，重点还是要管住嘴，七分靠吃三分靠练，但是如果吃的东西准备的太复杂，或者准备需要花费的时间太多，那肯定也是没办法坚持下去的。试想一下，早上起床以后（甚至提前一天）还得跑去厨房准备各种食材，还得准备好中午吃的东西，打包带去公司，与我而言，那是万万做不到的。</p><p>上面三点，听起来似乎胖子们就没救了？下面就来说一说我是如何坚持下去的。</p><h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>首先需要了解一个简单的道理，要想让体重下去，每天摄入的能量，一定要小于每天消耗的能量，所以我们需要做的第一件事情就是找一个 APP 记录自己每天摄入的能量。为啥一定要找一个 APP 来记录呢？有这么一堆原因：</p><ul><li><strong>你不知道食物的能量有多少</strong>，比如酸奶，你知道一盒酸奶有多少能量么？你知道一根牛肉干的能量有多高么？你知道食物的碳水、蛋白质、脂肪等情况么？我估计你一点概念都没有，没关系，APP 知道；</li><li><strong>你记不住吃了多少</strong>，去一趟食堂，阿姨往你的盘子里打了一堆东西，你记得住自己吃了几块肥肉，几片火腿肠，几根青椒，几块萝卜，几口汤么？你记不住，记住了你也算不清楚，没关系，APP 算得清楚；</li><li><strong>你不知道食物的配比是否正确</strong>，早上吃了两个包子，中午吃了一块牛肉，晚上又吃了几盒水果，今天摄入的蛋白质够不够，碳水是不是偏多，你不知道，没关系，APP 可以告诉你。</li></ul><p>如果你自信自己可以算清楚每天的摄入量，我依然建议你使用 APP 记录，通过数据观察自己每天的摄入情况，对比体重的变化，可以更好、更快地找到适合自己的饮食结构。</p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>下面我来详细从数字上解释下，如何合理地控制饮食。</p><p>首先，你得知道每天不吃不喝不动也会存在消耗，这个消耗是人体的基本消耗，咱不搞什么复杂的算法，记住下面这个公式（统一使用千卡做单位，千卡又称大卡，亦称卡路里，下面简称卡）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">每日的基本消耗（卡）~= 你的体重（斤） * <span class="number">12</span></span><br></pre></td></tr></table></figure><p>比如我减肥前的基本消耗大概为 1980 卡，这个算法比较粗暴，不算很准确，主要我觉得没必要算那么清楚，知道大致的就行了，如果你有运动的话，消耗量会大一点：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如走五六千步或者跑两三公里</span></span><br><span class="line">运动（卡）~= 体重（斤）* <span class="number">14</span></span><br></pre></td></tr></table></figure><p>运动消耗大概 2310 卡，这个也不准确，不过没关系，大致了解这个数值就行了，搞这么简单是为了好记。基本所有的食品包装袋上都会标注能量表，大部分会采用千焦耳做单位，它与卡路里的换算公式为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 卡 = <span class="number">4.18</span> 千焦耳 <span class="comment">// 简单一点，4 倍关系</span></span><br></pre></td></tr></table></figure><p>以后看到食品包装袋上标注的焦耳数值，除以 4，大概就是摄入的卡路里能量值。如果我想要减肥，每天摄入的能量就必须保证低于 1980 卡，你知道这个能量大概是多少么？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 个肉包 = <span class="number">210</span> 卡</span><br><span class="line"><span class="number">1</span> 碗米饭 = <span class="number">232</span> 卡</span><br><span class="line"><span class="number">1</span> 份五花肉 = <span class="number">426</span> 卡</span><br><span class="line"><span class="number">1</span> 盒酸奶 = <span class="number">180</span> 卡</span><br><span class="line"><span class="number">1</span> 个肉松面包 = <span class="number">391</span> 卡</span><br></pre></td></tr></table></figure><p>随便早餐一盒酸奶+一个包子，午餐一碗米饭+两个菜，晚饭一碗米饭+一个菜，就会达到 2100+ 卡了；更不用说，还会吃几盒水果，外加一点零食，还有夜宵，或者偶尔吃个火锅、烧烤等等，随随便便就 2500+ 甚至三四千卡。</p><p>看到上面这些数字，是不是已经找到自己持续长肉的源头啦？</p><h4 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h4><p>初期减肥时，一定要与米饭、肉类、油水等食物 Say Bye，随便找个 APP 查询下就会知道，碳水和脂肪类的能量都太高了，而且碳水还有个问题，能量高且容易消耗，简单来说，你吃两碗米饭，稍微动一动就又饿了。</p><p>当然，食堂基本也不要想着再去了，不管是自助餐厅还是阿姨给你打菜的那种食堂，都很难计算卡路里，各种食物掺杂在一起，加上还不知道菜里放了多少油，随便一顿下去，可能一整天的卡路里预算就花光了。</p><p>我的计划是每天吃 5 顿，早中晚三餐不能少，上午和下午各加餐一顿，基本上只补充碳水和蛋白质，不碰脂肪类食物。三个时间段的能量配比大概是 4:4:2，如果当天有运动的话，大概是 3:4:3，总摄入量一般建议是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">每日总摄入能量（卡） = 基本消耗（卡） - <span class="number">500</span>~<span class="number">800</span>（卡）</span><br></pre></td></tr></table></figure><p>初期我是直接减 1000 卡，也就是总摄入量在 1000 卡左右（基本消耗约 1980 卡），属于有点猛烈的，正常配比大概是：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">上午（早餐 + 上午加餐）：<span class="number">400</span> 卡</span><br><span class="line">中午（午餐 + 中午加餐）：<span class="number">400</span> 卡</span><br><span class="line">晚上（晚餐 + 晚上加餐）：<span class="number">200</span> 卡</span><br></pre></td></tr></table></figure><p>晚上如果不是特别饿的话，不会加餐，如果当天有运动，总摄入量可能会调整到 1200~1400 卡。保持这个比例，然后不断的挖掘和适应自己最喜欢的食物和配餐。</p><p><strong>上午餐</strong></p><p>我的早餐比较固定，一般就是 <code>一大碗脱脂牛奶 + 麦片</code>，不到 300 卡，或者吃 <code>一个玉米 + 一个鸡蛋白</code>。每次加餐补充 200 卡，大概就是 <code>一个苹果 + 一个香蕉</code> 或者 <code>一个玉米 + 一个鸡蛋白</code> 的能量。</p><p>前两个月用的脱脂牛奶，后面用的鲜牛奶（主要是附近超市好像不提供脱脂牛奶了），牛奶和麦片随便就能买到，而且容易做，基本两分钟就能搞定（凉牛奶微波炉加热一分半），三分钟能吃完，一点都不耽误时间。偶尔起的早，会煮玉米和鸡蛋，或者去公司的超市购买。</p><p>麦片我不建议买燕麦片，太难吃，我买的是水果麦片。你会发现，我的配餐都是很容易凑齐，而且也是我喜欢吃的。一定得找自己喜欢吃的，否则，你想想，你如何坚持几个月？</p><p><strong>中午餐</strong></p><p>午餐基本就是吃沙拉，前一个月一点肉都没有，后来实在是坚持不下去了，加了点鸡胸肉、牛肉、鱼肉之类蛋白含量比较高的食物。再后来，我发现午餐超标吃一点「非健康」食物似乎也不怎么影响体重的下降，于是就改成了帕尼尼、吐司等等，不过我还是建议你先多吃水果蔬菜，等体重有了一点变化后，再加点料。</p><p>沙拉很多人都不爱吃，我也一样，所以我会尽量吃自己喜欢的，比如海带多一点的，或者小番茄多一点的沙拉。能够坚持吃一个月纯蔬菜沙拉的，都是牛人，比如我，哈哈，我自己都佩服我自己 ；）</p><p>下午我会去水果店买点自己喜欢的水果，或者继续补充点蛋白，吃些牛肉干或者鸡蛋白。上次从内蒙回来，我带了两袋子牛肉干，一根牛肉干大拇指那么粗，比筷子还长，大概也就 50g，能量大概 200+ 卡的样子，比较适合作为加餐食物。在家，吃牛肉干比较多；在公司，去水果店和甘其食比较多，还可以多走几步路，来回也有一两千步。</p><p><strong>晚上餐</strong></p><p>晚上就很简单了，基本就是黄瓜、小番茄、水果之类的，多吃一点问题也不大，基本就是保证 200 卡左右的摄入，如果有运动的话，会适当补充蛋白质。</p><p>我还挺喜欢吃鸡蛋番茄汤的，有一段时间，我会特意早早回家，给自己做一碗鸡蛋番茄汤，不放油。一般汤水放的挺多，一大碗下去，肚子都会很撑…</p><h4 id="自由日"><a href="#自由日" class="headerlink" title="自由日"></a>自由日</h4><p>如果一直保持低能量摄入，一段时间后，身体可能会适应这种环境，慢慢地，基础代谢会降低，每日的基础能耗也会降低，如果想继续维持体重的下降，便只能继续降低摄入量，长期如此对身体肯定是有害的，<strong>所以身体需要每周有一天或者至少有一餐是正常甚至过量摄入的，这是一顿欺骗餐，欺骗身体还有正常的摄入，基础消耗请不要降低。</strong></p><p>我一般把周六当做自由日，这一天中午，我会自己做一顿饭，下重油，敞开了吃，或者直接下馆子，整点烧烤、火锅之类。</p><p>这里需要注意的是，一般自由日过去后，体重会回升 2~5 斤，这是正常的，在下一周的周二、周三就会回落到之前水平。保持如此，前一个多月，我每周会减重 2~3 斤。</p><p>掉肉十五六斤的时候，我放宽了自由日的定义，每周会有 3~4 次在外面胡吃海喝，当然，结果就是花半个月才能掉 2~3 斤。虽然是胡吃海喝，但是吃的时候还是挺注意的，首先，我不吃米饭，然后就是只摄入高蛋白食物，尽量不碰油脂。</p><p>几个月下来，我戒掉了碳水。以前只要肚子饿，首先想到的是辛辣的美食，然后心中就会冒出两个字「下饭」+ 流口水，现在已经没啥感觉了。</p><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p>刚开始没怎么运动，等到身体从 16x 突破到 15x 的时候，热情高涨，血脉澎湃，每周都会破天荒地有 1~3 次的室内跑步，每次运动大概 15~30 min，保证全身湿透才会停下。要知道以前三个月能跑一次都是很奢侈的事情。</p><p>两个多月下来，体重下降 10kg，小米体脂秤的综合分从 60 分变成了如今的 81 分；之前有轻微的脂肪肝，现在应该没有了；肚子上的肉也不明显了，甚至还出现了一点点肌肉的痕迹；三下巴现在也消失了，现在只剩下一点点双下巴的痕迹。</p><p>其实结实的胖子减完肥，效果并没有那么明显，比如我，看起来也就是脸小了一点。只有自己能感觉到，整个身体轻松了很多，人也健康了不少。</p><p>由于 20 斤的目标已经达成，为了保持这种身材以及瘦身的心态，我决定，将当初的目标调整为 15kg，也就是说未来 2 个月的时间，我还会瘦 5kg，但是后续的减肥，我会尽量通过运动来控制，五分靠练五分靠吃，甚至六分靠练四分靠吃，今年的总体目标是 <strong>不限制自己的嘴巴，找到运动（拳击也好、游泳也好、撸铁也好）的乐趣，然后继续保持体重的稳定。</strong></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上，啰啰嗦嗦说了一堆了，大概就是我最近两个月的所有减肥心得了。</p><p>后续，我应该会通过同样的方式 <code>目标 - 定制 - 行动 - 调整</code>，从运动而非饮食的角度让自己变得更加健康，这个阶段的摸索周期可能会更长一点，不过最近好像已经有了努力的方向，等我有了更多靠谱的经验，再跟大家分享吧~</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/07/28/my-way-to-lose-weight/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[破局 - 纯粹的执行者]]></title>
      <link>http://www.barretlee.com/blog/2019/07/18/to-be-yourself-in-company/</link>
      <guid>http://www.barretlee.com/blog/2019/07/18/to-be-yourself-in-company/</guid>
      <pubDate>Thu Jul 18 2019 14:19:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>不管是大公司还是小公司，你都可以看见这类主管：他不断地从外面接活儿进来，然后排好时间、分好任务指派给你。在这样的主管下，你的角色更像是一个单纯的执行者，稍微好一点的情况是，他会给你安排大块的事情，糟糕一点的情况是，他指派给你的任务特别离散，不聚焦，让你东搞一下西搞一下。</p><p><img src="/blogimgs/2019/07/18/to_be_your_self_in_company.png" alt="破局"></p><p>明白自己处境的人，会忧虑，不明白的人，还觉得自己很充实。如果你恰好有这样的感觉，我可以告诉你几个破局的思路。</p><h4 id="1、不要把自己当成执行者"><a href="#1、不要把自己当成执行者" class="headerlink" title="1、不要把自己当成执行者"></a>1、不要把自己当成执行者</h4><p>很大一部分原因还是因为，你自己把自己当成了执行者，你不愿意去分析需求或者不懂得如何去分析需求，你没有一个长期的聚焦的目标，结果就是你的主管会帮你做好这一切，他会根据团队今年的目标分析出几件核心的事情，然后将事情细化之后分派给团队的同学，如果你有一定的规划能力，他可能会把一整件事情交给你，如果没有，那大概率就是东边人手不足把你推过去，西边时间紧急把你拉回来。</p><p>提升自己的主观能动性，主动去 Owner 一块事情，给出详细的规划和落地方案，不断找主管和合作伙伴对焦，自然而然你的规划力就显露出来了。不要把自己当成执行者，而是 Owner。</p><h4 id="2、帮助你的主管认识到自己的问题"><a href="#2、帮助你的主管认识到自己的问题" class="headerlink" title="2、帮助你的主管认识到自己的问题"></a>2、帮助你的主管认识到自己的问题</h4><p>很显然，把下属当做执行者也是主管的问题，任何一个人都是可培养的，否则当初也不会把你招进来，你可以找主管沟通，告诉他你最近处于什么状态，其实很可能在给你委派零散需求这件事情上，他并没有意识到会不利于你的成长，你需要吐露自己的心声，告诉主管你想得到什么，而现在的工作方式可能让你拿不到想要的结果。</p><p>主管也有能力强和能力弱的，对于没有太多管理经验的主管，他做事可能依然是当初个人作战时的风格，关注的是事情，没有考虑到人的成长。</p><h4 id="3、搞清楚团队的目标和个人的目标"><a href="#3、搞清楚团队的目标和个人的目标" class="headerlink" title="3、搞清楚团队的目标和个人的目标"></a>3、搞清楚团队的目标和个人的目标</h4><p>一个没有目标的团队是难以凝聚到一起的，在定义个人目标之前，你首先需要知道团队的目标是什么，说得直白一点，你需要知道主管今年的目标是什么，想一想自己承担了主管目标的哪个部分，偏离的太多肯定是不行的，个人的核心目标一定要与团队目标进行对焦。</p><p>目标一定是有挑战的，也是能拿到结果的，当你在执行任务的时候，可以去想一想，我手头的事情是否是完成个人目标的必做事项，如果不是，你就得想办法做取舍，至少得排个优先级。</p><h4 id="4、敢于-Say-No"><a href="#4、敢于-Say-No" class="headerlink" title="4、敢于 Say No"></a>4、敢于 Say No</h4><p>有的人敢跟需求方怼，但是在主管面前却毫无勇气，原因是主管会给你打绩效，他会影响你未来一年的涨薪、晋升等，所以对主管会言听计从。这显然是不对的。你是团队的一份子，你今年拿不到结果，也就意味着今年团队有一部分的结果堪忧，所以你在团队里无时无刻都扮演着重要的角色。</p><p>遇到不合理的需求，即使是主管指派的任务，你也要勇敢地站出来，告诉他，你错了，指出主管的错误，是为了自己好，更是为了团队好，你指出的问题越多，团队走偏的可能性就越低，你一定要明白这个道理。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/07/18/to-be-yourself-in-company/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[研发人员在整个市场已经趋于饱和，未来还会有更多的裁员和更加残酷的竞争？]]></title>
      <link>http://www.barretlee.com/blog/2019/07/16/why-fe-improved/</link>
      <guid>http://www.barretlee.com/blog/2019/07/16/why-fe-improved/</guid>
      <pubDate>Tue Jul 16 2019 14:15:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>最近一段时间是阿里的晋升季，前端方向与往年不一样的是，高 P 涌现的趋势越来越明显，这说明前端这个领域已经进入了新的高度。</p><p>其实回首想一想也能感受到，曾经的前端还被定义为 JS 工程师/重构工程师，现如今市面上的 JD 几乎已经看不到这两个词的影子了。</p><p><img src="/blogimgs/2019/07/16/why_fe_improved.png" alt="残酷的未来"></p><p>仔细想一想，核心的原因是什么？是哪些因素把资源角色的前端推到了主导业务的角色。我觉得有这么几点：</p><ol><li><p>Node.js 的出现，让前端具备了 Server 端的能力，虽然拥有的能力并不多，但是全栈这个概念让很多资深工程师趋之若鹜，甚至引来了一些其他领域的工程师，前端队伍突然壮大，各种思想碰撞后，前端自然也就拓展了边界。</p></li><li><p>多端技术的融合，为了节约生产资源，提高生产力，很多大厂都投入了大量的人才进入跨端生产的技术研究之中，前端在 Native 上又多了一次学习的机会，甚至一度有着统一三端的雄心。不过目前还尚未能看到终局，Flutter 也不一定是未来。</p></li><li><p>基础能力和基础工具收敛以后，前端之间工作内容的相似性越来越突出，这吸引了很多整合能力较强资深工程师，为了提升可复用性和使用效率，横向挖掘了大量有价值的解决方案。从解决小问题变成解决大问题，问题的量级不一样，自然对能力的要求也不一样。</p></li><li><p>商业的进化也铸就了前端，这一层的理解可能有点绕，但是我觉得也算是重要原因之一：前端是与用户最贴近的一个技术工种，无论是用户对体验的诉求，还是企业对服务质量的要求，都促使着前端不断地突破自我，寻找新的思路来迎合来自企业和用户的双重挑战。</p></li></ol><p>尽管近两年前端发声稍微小了一些，但是这并不意味着前端这个行业会衰弱下去，市场对前端工程师的需求量还会随着 5G/IoT/VR/AR 等技术的革新继续增长，只不过对人的要求可能会有一些变化。</p><p>首先是学习能力，学习能力不仅仅是你看懂某个技术知识点的能力，更需要有人能够将技术整合到商业之中，这也是需要强大的学习能力的，没有良好的基础和各种方案的长期实践，很难做好这件事情。这里可能更加强调学习并创新的能力，学，以致用。</p><p>其次是突破的能力，未来的前端一定是越来越难做，因为好做的事情，能快速出成绩的事情会越来越少，我们遇到的大概都是些硬骨头，啃碎了才能吸到骨髓，不想啃，就没有你的机会，啃不动牙碎了，你就直接被淘汰了。</p><p>有人在唱，研发人员在整个市场已经趋于饱和了，未来还会有更多的裁员和更加残酷的竞争，我也认可这个观点，未来会更残酷，我们要做的不应该是自怨自艾和畏畏缩缩，如果你还想跟着这个时代一齐向前，就必须振奋起来，披荆斩棘！</p><hr><p><strong>题图</strong>: <a href="https://unsplash.com/photos/Up_qnNWO7IY" target="_blank" rel="noopener">https://unsplash.com/photos/Up_qnNWO7IY</a></p><p><strong>2019-07-16</strong>：打个小广告，淘宝前端工程团队还在招人，2020 年毕业的校招生，以及 P7 的社招（有极少量 P6+ 的坑位），都要，需求量还挺大，有意者可以邮件联系我，<a href="mailto:barret.china@gmail.com" target="_blank" rel="noopener">barret.china@gmail.com</a></p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/07/16/why-fe-improved/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[聊一下，为什么前端会发展这么“快”，再聊一下为什么前端会发展这么“慢”]]></title>
      <link>http://www.barretlee.com/blog/2019/06/27/the-root-reason-for-the-developing-of-fe/</link>
      <guid>http://www.barretlee.com/blog/2019/06/27/the-root-reason-for-the-developing-of-fe/</guid>
      <pubDate>Thu Jun 27 2019 12:04:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>聊一下，为什么前端会发展这么“快”，再聊一下为什么前端会发展这么“慢”。</p><p>前端这个概念出现的时间不算很早，但差不多也有 10 多年了，也不短了。前几年大家都在喊变化太快，学习的步伐跟不上社区的发展，为什么会出现这样的声音？前端到底以一种什么样的速度在演进？下面，我们跳跃到逻辑的最底层，一起来探讨分析下。</p><p><strong>1、硬件环境在进化</strong></p><p>根据摩尔定律，当价格不变时，集成电路上可容纳的元器件的数目，约每隔 18~24 个月便会增加一倍，性能也将提升一倍。想想十年前你用的什么手机？Nokia、Motorola 都算是潮流机吧，经过 5~7 个摩尔周期以后，现在呢？随便一个三百块钱的机器屏幕分辨率、内存和 CPU 能力都可以秒杀当年的初级智能机。硬件环境的变化让整个互联网的基建设施变得更加流畅，甚至慢慢地，我们已经感受不到网速给上网带来的影响了，尤其是 5G 时代的即将来临，我们几乎不需要手机上具备大储存能力，所有的数据放在云端，瞬间就能下载到本地，即便是看 8K 视频都能达到无缓冲效果。</p><p>硬件的发展，让信息从真实世界传输到网络世界的效率变得更高，从文字到图片，到音视频，到直播，再到 VR/AR，每一种新的富媒体出现，都会给前端带来各种不同的挑战，每次给人的感觉都是一次全新升级。我相信这种变化还会持续下去，未来的网络世界一定会在真实世界产生更多的虚拟现实，并深刻影响人们的生活。</p><p><strong>2、互联网在进化</strong></p><p>从 Web 1.0 到 Web 2.0，互联网从一个信息源渠道的角色变成了人和人之间串联的纽带，人们的非物质需求变得更加旺盛。整个互联网也从一个中心式发展结构演变成了多中心甚至分布式结构，每个人都成了自媒体。人与人之间的交往已经脱离了时间和空间的限制，你在网络上喊一句话，可能会有来自五湖四海的人的回应，你白天喊一句话，可能晚上还能有人在回复，甚至一个月后还有人在与你交流。人们的社交域已经从方圆 100 公里突破到了整个星球，对信息的流动速度和质量也有了更高的要求。随着 Web 3.0 的出现，整个网络变得更加智能，信息本身就具备了识别、过滤、筛选、匹配等能力，人和人之间的关系模型也变得越来越复杂。</p><p>互联网的发展，让信息的形态和结构变得尤其丰富，让人们对信息的多元化呈现和信息触达的及时性需求变得更加强烈，这一切将前端技术不断推向新的高潮，出现了很多适应时代变化的技术，如 Ajax/Websocket/WebRTC/PWA-push，再如 Animation/SVG/Canvas/WebGL 等等。</p><p><strong>3、商业环境在进化</strong></p><p>在人和网络之间不断地会出现新的跨时代容器，从各类门户网站到各类通讯软件，然后慢慢渗透到人们生活的方方面面，配合大数据和数据智能，又衍生出更多影响甚至改变人们生活方式的互联网产品，这一切都是因为商业在后方不断输送新的能量。在这个信息时代，能被数字化的内容都将纳入商业的范畴，数字化带来更多的商业价值，而更大的商业价值也会驱动更强的数字化革命，我们就身处在这个时代。</p><p>商业环境的变化，让互联网不断地与人打交道，这也导致了商业产品会更加贴近人，考虑人的问题，服务人的生活，影响人的观念，这些都会让前端变得更加复杂，也会让前端为了应对这一切不断地革新自己。通过技术的组装让呈现和交互的成本变得更低，因此有了各类框架的迭代和升级；通过更强的规则和约束让不同形态和不同域的产品具备更多的相似性，因此有了各类技术规范和标准的发展；通过更广域和更底层的技术平台来保证上层技术更好地为业务服务，因此出现了安全、工程、多端、跨栈等技术的崛起。</p><p>硬件是基础，商业在推动，需求来自人，改变在网络。</p><p>这十年，前端的活跃度在整个互联网技术圈都有目共睹，前端的核心语言 JavaScript 也从一个脚本小子晋升到鼎鼎有名的豪门大家，看起来前端这个行业在飞快地成长着，但是细细品味，其实会发现，前端跑得很慢，像一只乌龟一样。</p><ul><li>第一个阶段是因为浏览器的发展，那是 PC 之战，在这个过程中，前端沉淀下来的东西似乎并不多，只是这个岗位被炒热了；</li><li>第二个阶段是无线时代的到来，为了提高生产力，前端几乎钻进了所有邻居的床上，有着一统用户端的霸气，而沉淀的内容却只是一堆即将或已经淹没在历史红尘的技术垫脚石；</li><li>当前阶段更多的是从体验、效率层面着手，将其他领域优秀的思考搬迁到前端领域，思考的边界也很多，我觉得还在探索之中；</li></ul><p>前端给人的感觉始终还是散乱的，不成体系的。后来，大家开始淡化前端这个词汇，出现了多端、大前端、云+端的概念，这也说明前端具备了更强的包容度。</p><p>不可否认，前端的发展给业务带来了巨大的价值，但是从厚度和深度上来看，还有很长的路要走。但，可能，也没准，前端还是会一直这么浪地发展下去；）</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/06/27/the-root-reason-for-the-developing-of-fe/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[理解 Flutter 和 RN/Weex 的差异]]></title>
      <link>http://www.barretlee.com/blog/2019/06/21/the-difference-between-flutter-and-weex/</link>
      <guid>http://www.barretlee.com/blog/2019/06/21/the-difference-between-flutter-and-weex/</guid>
      <pubDate>Fri Jun 21 2019 12:02:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p><img src="/blogimgs/2019/06/21/flutter.png" alt="upload successful"></p><p>Flutter 和 RN/Weex 的差异，核心在于渲染的基础由自己实现，简单来说，</p><ul><li>Flutter 的代码经过 Flutter 引擎直接就渲染到了屏幕上</li><li>而 RN/Weex 的代码需要先跑到 Native 层处理一下，然后经过 Native 层渲染到屏幕</li></ul><p>很显然前者效率会更高。由于 Native 组件可能会随着系统的升级跟着一起升级（API 增、删或变化），RN/Weex 需要写很多胶水层代码来适配不同版本、不同平台的 Native 组件，而 Flutter 就不存在这个问题，但 Flutter 却不能像 RN/Weex 那般可以直接使用 Native 提供的丰富组件和属性，它需要使用 Flutter 引擎暴露出来的底层 API 做封装，</p><ul><li>比如要具备 Flex 布局能力，就需要写一个 Flex 引擎来识别上层的 Flex 语法</li><li>比如想使用 React 的 DSL，上层就必须实现一个类 React 框架来对接 Flutter 引擎提供的渲染 API</li><li>再比如想使用圆角、投影等等，就必须增加一种渲染策略来实现圆角效果和阴影效果等等</li></ul><p>好在 Flutter 社区针对 Android 和 iOS 分别实现了一套适合各自系统风格的组件，长得跟 Native 一样。如果这些组件不能满足开发者的需求，开发者也可以很轻松地定义一种新的组件，这对开发者显然是十分友好的，我们可以拿到非常底层的 API 做各种想实现的效果，而且性能还特别高。</p><p>Flutter 引擎之上有一层是 Dart，事实上它就提供了上面我们所说的 Flex 布局能力、类 React 的 DSL 能力、各种动画、CSS rule 等，其实现方式就利用 Flutter 引擎提供的比较底层的可以直接在 GPU 上渲染的 API 能力。</p><p>如果你想用 Vue 的 DSL 写 Flutter 行不行？其实也是可以的，但是需要有人写一个 Vue 的框架来对接 Flutter 引擎提供的渲染 API，Flutter 引擎就像一个 Driver 层，保证了在各端上的渲染一致性，需要开发者在 Driver 之上进行自己的框架抽象、组件抽象等。</p><p>以上，可能表述存在一些偏差，但是基本就是这么个意思。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/06/21/the-difference-between-flutter-and-weex/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[提升结构化思考力]]></title>
      <link>http://www.barretlee.com/blog/2019/06/18/thinking-framework/</link>
      <guid>http://www.barretlee.com/blog/2019/06/18/thinking-framework/</guid>
      <pubDate>Tue Jun 18 2019 11:57:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="一、"><a href="#一、" class="headerlink" title="一、"></a>一、</h2><p>很多人在遇到复杂需求或者陌生领域问题的时候，脑子里便是一团浆糊，东一锥子西一锥子，把事情越搞越乱，最后拿不到结果，究其原因，是缺乏结构性、系统性的思考。</p><p>通常有两种路径来提升结构化思考力：</p><ol><li>在明确核心问题的情况下，建立中心，通过对核心要素进行分解，形成旁支结构，然后对旁支就行合并、修剪、删除等操作，收敛最终的高权重旁支，然后进一步寻找对策、制定方案；</li><li>在不明确核心问题的情况下，从人、事和势等几个维度进行问题发散，获取全面多视角的问题集，然后进行多层的分类、剪枝和归并操作，汇总成一个中心，然后执行步骤 1。</li></ol><p>在归纳旁支的时候，有两个重要的原则是：完整性和正交性，即确保问题不重叠、不遗漏且相互独立。有几种不错的分解问题的思路：</p><ul><li>从时间顺序思考，比如安排一次技术大会，思考每个环节会遇到什么问题</li><li>从结构顺序思考，比如跨团队的业务合作，思考团队对内和对外的职责，对上和对下的策略，业务的边界等</li><li>从程度顺序思考，比如提升网站的回访率，思考产品结构、运营策略、用户体验、品牌推广等等的重要度，厘清主次</li></ul><p>在分解和收敛问题的过程中，需要注意的是：</p><ol><li>泛化抽象，同类、同区间问题合并，不断明确泛化边界点</li><li>查漏补缺，通过对比、派生等方式，分析缺失部分，可以参考 SWOT 分析法，从优势、劣势、机会、威胁这四个方面考虑问题</li><li>删除枝叶，抓大放小，分清阶段性需要解决的问题</li></ol><p>结构化和系统化的思考力是可以培养的，平时遇到问题建议多强化训练，比如可以动手针对职业发展、业务需求、年度规划等问题在 XMind 上画一画。</p><hr><h2 id="二、"><a href="#二、" class="headerlink" title="二、"></a>二、</h2><p>在做计划的时候，少不了枚举问题或者事情，往往很多人枚举域局限于脑子的热度，兴奋的时候能冒出一堆 TodoList，没感觉的时候就跟挤牙膏一样，什么事情都想不出来，比如现在让你思考下「提高自己」这件事情，是不是蹦出来的都是多读书、多交流、多思考，然后就要挤牙膏了。</p><p>思考的时候，如果有一个 Thinking Framework 可以参照的话，可能会轻松很多。在上面的讨论中我提到过一个 SWOT（Strength-Weakness-Opportunity-Threat）分析法，这是一种思维工具，相关的文章在 Google 上能检索到一大堆，下面主要是尝试分析下，这种工具为什么可以帮助我们更好地思考问题。</p><p>当我们把一个问题分解成更细的问题或者任务的时候，如何保证不漏项？如何保证拆分出来的内容不存在交集？这是我们首先需要思考的问题。</p><ul><li>不漏项，是确保拆解的完整性</li><li>不重复，是确保拆解的正交性</li></ul><p>我们挤牙膏的动作就是为了保证自己分析的完整性，但是挤牙膏这种脑暴式的问题分解方式往往得不到完整的问题集，怎么办呢？上次我讲过可以从时间、程度、结构等方式进行分析，因为这几个因素都是连续的，连续就一定不会遗漏；还有一种暴力的方式，N 和非 N，逻辑上正反相对面一定可以囊括所有情况，然后提取新的变量 M，在 N 的基础上分出 NM 和 N 非 M，依此类推。</p><p>SWOT 分析法就是从两个对立分解因子上帮助我们剖析问题的，一个因子是内外边界，SW 是内部环境，OT 是外部环境；另一个因子是好坏边界，SO 是优势面，WT 是劣势面。通过这两个因子可以比较好的把工作所处的优势、劣势、机会和威胁分析得很清楚，同时让你明确机会的优劣是什么，威胁的优劣是什么。</p><p>上面我说的不漏项不重复，其实是一种分析法，叫 MECE（Mutually Exclusive Collectively Exhaustive），意思就是“相互独立，完全穷尽”，也可以去 Google 学习下。任何一种结构化思考力都需要通过长期的刻意培养才能形成习惯，多锻炼，一个好的途径是，多画图，多写 PPT。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/06/18/thinking-framework/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[如何成为一名优秀的业务人员/工程师？]]></title>
      <link>http://www.barretlee.com/blog/2019/06/15/to-be-excellent-in-work/</link>
      <guid>http://www.barretlee.com/blog/2019/06/15/to-be-excellent-in-work/</guid>
      <pubDate>Sat Jun 15 2019 12:01:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>如何成为一名优秀的业务人员/工程师，我觉得需要反复把下面四件事情做好：</p><p><strong>1、确定一个有挑战的目标</strong></p><p>且不说选一个具备挑战性的目标，很多人根本就没有明确的目标，浑浑噩噩的，也不知道自己究竟想要什么，自然也不会过多地去思考自己有什么优势，有什么劣势，能做成什么事情，更不会去想，如何创造新的价值，找到新的效益。明确的目标让我们的行动更加聚焦，而有挑战的目标会让我们从心底就涌出一股向上的动力，不仅可以找到新的价值点，也可以帮助我们更好地提升自己。</p><p>0 代表几乎不用力就可以达到的目标，10 代表几乎不可能完成的目标，如果从 0 到 10 给自己的目标打分，你的目标应该在 7 分左右。</p><p><strong>2、全面、透彻地分解问题（简单的问题复杂化）</strong></p><p>目标定好了以后，马上行动是不可能的，因为挑战性的目标并不会那么容易达成，就算方向是明确的，如果没有做好周全的计划，行动也是难以持久的。首先我们需要从各个方面对目标进行详细分解，这个过程是为了让简单的事情变得复杂，是为了控制好未来可能会遇到的各种风险，找到行动预案。</p><p>根据目标分解出 2~3 件具备可评估因子的事情，同时提前思考，如果半年后我没有达成目标，或者彻底失败了，可能的原因是什么。</p><p><strong>3、有条理、有节奏地践行（复杂的问题做简单）</strong></p><p>如果想的很复杂，做起来也特别复杂，那一定是想的有问题，或者执行上存在问题。让行动变得简单，可以让我们的精力聚焦在几件核心的事情上，把核心事情做好，同时也可以帮助我们一定程度控制成本。简单可以让人记住，简单可以聚焦，简单可以让内心保持宁静。</p><p>行动过程中，不断对焦目标，不断反思。所谓反思，先有思，再有反思。反思就是拿当前的事情与最初定下的事情作对比，反思不仅仅是事情结束以后再去思考，在行动前、行动中和行动后，都应该反思。</p><p><strong>4、分享失败和成功的经验</strong></p><p>如何看自己是否真的理解了一件事情？我觉得你能够把它明明白白地讲给外行人听，那就是理解了。我觉得理解有三个层次，知识、行动和态度，知识是肤浅的，知识是死的，而深入的理解知识可以指导行动，完整地理解会影响一个人的态度。</p><p>一个团队需要传承，一家企业更需要传承，知识需要被分享，经验和教训同样也需要。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/06/15/to-be-excellent-in-work/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[如何杜绝一句话需求？]]></title>
      <link>http://www.barretlee.com/blog/2019/06/14/principles-before-req/</link>
      <guid>http://www.barretlee.com/blog/2019/06/14/principles-before-req/</guid>
      <pubDate>Fri Jun 14 2019 11:55:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>如何杜绝一句话需求？首先我们来看看什么是一句话需求：</p><ul><li>“把这个视觉稿还原下，明天交付给产品”</li><li>“这个开放接口再增加一个额外的开放功能，给外包场景使用”</li><li>“给我跑一个数据报表，分析下近期的用户行为”</li><li>“把这个 Icon 调大一点”</li></ul><p>我们经常会提到用户故事这个词，从用户故事中会抽离出一些业务上和技术上的需求，然后针对需求做细分产生一系列任务。很多一句话需求就像是一个任务，没有背景，没有分析，没有评审，直接扔过来交给你，此时你的角色只是一个简单的执行者。</p><p>那如何杜绝呢？有两个策略，最常见的是，给需求加要求：</p><ul><li>没有详细背景的需求不接</li><li>看不到业务价值的需求不接</li><li>没有数据预期的需求不接</li><li>频繁更改的需求不接</li></ul><p>这种策略是一种守的姿态来应对“外部刺激”，很被动，倘若拒绝得过于粗暴还不利于与合作方的长期共存。给偏爱使用这种策略的同学几点建议：</p><ul><li>首先，不能说不（Never say no）</li><li>你应该说“好，我接受，但是……”，注意这里的但是</li><li>“我不保证质量/我不保证时间/我既不保证质量也不保证时间”</li><li>“除非，你砍点需求/延长点时间”</li><li>此时，再和谐地抛出你的要求：能不能先想清楚业务价值，能不能给一个确定不改的需求，能不能给出数据预期等等</li></ul><p>通过这种委婉且合理又不伤感情的方式，倒逼需求方按照你的要求做事情，这是一种“守”的策略。另一种策略是“攻”，主动出击，梳理自己的问题和需求方的目标，深入敌方：</p><ul><li>目前我的系统存在哪些问题，安全、性能、稳定性、可拓展性等，确定最致命问题</li><li>需求方的长期目标是什么，阶段性目标是什么，近期目标是什么</li><li>从长期来看，我的系统需要沉淀什么能力来应对需求方</li><li>需求方提过来的需求要实现他哪个阶段目标，他提的需求是否真的可以实现他的目标，他是如何分析的，我结合他的分析能否得出同样的结论</li><li>为什么他总是会提出一句话需求，他的需求源是从哪里来的，他的老板？他的客户？他的合作伙伴？</li><li>能不能让他的需求源在给他传递消息的同时也传递给我，至少让我知道他消化需求的姿势是正确的，对需求源的理解没有偏差</li></ul><p>兵家有云，知己知彼方能百战百胜，把己方的问题和需求方的问题都分析的妥妥的，然后按计划办事，经过一段时间的自我消化和自我调整，自然可以很好的扼制住如洪水般的需求。换一种说法就是，你要学会帮助需求方更好地分析问题，这个要求很高，需要你对业务有足够的理解和判断。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/06/14/principles-before-req/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[如何有效地提升执行力]]></title>
      <link>http://www.barretlee.com/blog/2019/06/11/improving-execution/</link>
      <guid>http://www.barretlee.com/blog/2019/06/11/improving-execution/</guid>
      <pubDate>Tue Jun 11 2019 11:51:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>有同学在交流圈子里感叹，“感悟和计划比较容易有，执行力就…呵呵了”，如何提升执行力，下面我来聊一聊，给个思路。</p><p><img src="/blogimgs/2019/06/11/improving-excution.png" alt="upload successful"></p><p>执行力是什么？百科上这么说的，<strong>所谓执行力，指的是贯彻战略意图，完成预定目标的实际操作能力</strong>。我们拆分下：</p><ul><li>首先我们需要有一个<strong>明确的目标</strong>，知道我们实际行动是做什么事情（Plan）</li><li>执行力是一种能力，是一种操作能力，也就是说需要我们付出<strong>实际行动</strong>（Do）</li><li>然后我们要理解目标，防止在实际操作的过程中误入歧途（Check）</li><li>如果误入歧途怎么办？<strong>及时作出调整</strong>，或者修正初始目标（Adjust）</li></ul><p>简单来说，<strong>执行力就是做事的能力</strong>，上面的拆分其实就是 PDCA 工作法的展示，这是一个循环的过程，调整目标之后，进入下一个 Adjust-Plan-Do-Check 的过程。那为什么你的执行力不强呢？其实道理也很简单，从上四个步骤中找原因：</p><ul><li>计划 Plan<ul><li>目标含糊，不知道自己要做什么</li><li>没有工具和手段来衡量目标</li><li>目标太大，几乎无法达到</li><li>目标太多，没有重点，目标之间没有关联</li><li>没有设定期限，无时限地行动下去</li></ul></li><li>执行 Do<ul><li>能力不足，无法达到</li><li>条件受限，无法达到</li></ul></li><li>检查 Check<ul><li>检查不及时，偏离轨道太久，可能已经没有继续的欲望了</li><li>检查项与考核内容不一致</li><li>越查事情越多，做着做着，脱离了目标</li></ul></li><li>调整 Adjust<ul><li>没有这个步骤</li></ul></li></ul><p>Plan 步骤中提到的 5 点其实就是 S.M.A.R.T 原则的基本要求，这 5 点都是反例。如果你定好了一个恰当的目标，在行动过程中不断地对焦，那么事情就不会过于脱轨。如何判断目标是否恰当呢，我的经验是：<strong>「有趣且有挑战」</strong>，比如：</p><ul><li>我要减肥并不是很好的目标，我想在沙滩上秀腹肌给一群妹纸看就好多了，你可以在每次健身和节食的时候都想象下那个画面</li><li>我要提升英语并不是很好的目标，我想一个人去国外旅游，欣赏国外的美景，尝遍国外的美食，这个画面就比较有意思了</li><li>我今年要看完二十本书并不是一个很好的目标，我想提升自己的结构化思考力，在跟人聊天、演讲、汇报的时候更顺利，这就有点动力了</li></ul><p>所以说，很多时候并不是你执行力不够，而是你的目标定的没有吸引力，或者目标定的太大或太小，如果你的目标刚刚好，你仍然不能坚持下去，那只有两个原因：</p><ul><li>你这个人啊，太没有<strong>毅力</strong>了</li><li>你这个目标达不达成，可能对你来说，<strong>无所谓</strong>（还是目标的吸引力不够）</li></ul><p>以上，希望对你有帮助。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/06/11/improving-execution/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[新人在中小公司遇到的成长困境]]></title>
      <link>http://www.barretlee.com/blog/2019/06/09/growth-in-startup/</link>
      <guid>http://www.barretlee.com/blog/2019/06/09/growth-in-startup/</guid>
      <pubDate>Sun Jun 09 2019 20:10:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>有个童鞋在一家创业公司工作，近期遇到了些 <a href="https://t.zsxq.com/Z7yniQv" target="_blank" rel="noopener">疑问</a>：“如何才算是高级前端开发工程师，以及在创业公司比较繁忙的情况下，如何更好的成长？”，对此他自己做了总结，以下几类事情占据了他主要的时间：</p><ol><li>公司最近为了融资需要快速更迭产品，所以需要大家在短时间内上线产品</li><li>工作不到一年，写代码熟练度还不够，所以开发速度不够快</li><li>为了产品更快上线，需要改同事写的 bug</li></ol><p>“所以导致工作以来属于自己的个人学习时间变少”，他说。</p><p><img src="/blogimgs/2017/04/26/006tKfTcgy1fezyf4npsuj30p00dw40s.jpg" alt></p><p>我想，很多职业新人都会遇到类似的问题，针对上面三个问题，我们来一一分析下，找到更加深层的问题：</p><ol><li>公司发展阶段，产品周期较短，需求不断</li><li>自己技能不足，难以满足公司短平快的开发要求</li><li>迭代的过程中，还需要维护历史遗留问题</li></ol><p>上面几点，是对他的问题做了归纳，但是大家应该看得出来，还不够凝练，没有找到核心问题，我们继续分析下：</p><ul><li>1 和 3 属于同类问题，公司在追求市场份额过程中，在各个方向发力，产品分支比较多，很多可能还是实验性的产品，在没有拿到结果之前，需要技术持续投入；</li><li>第 2 点属于个人问题，这个问题与上面的公司问题形成恶性循环，个人能力不够、业务繁忙导致时间不够，时间不够导致业务问题和技术债堆积，业务问题和技术债堆积导致时间更加不够，然后就递归恶化下去了。</li></ul><p>通过上面的分析，我们抽象出了两个因素，一个是个人因素，一个是公司因素，两个因素的连接点是时间不够用，如何解？</p><p><strong>① 如果你解决问题的速度跟不上问题出现的速度，那么堆积的问题就会越来越多，</strong>对应的策略是：</p><ul><li>提升自己解决问题的速度（个人因素问题），也就是不断补充知识量和提升编程能力，适当提升架构水平；</li><li>抑制问题产生的速度（公司因素问题）就比较困难了，你可以系统地学习下项目管理的知识；另外，与需求方搞好个人关系也会有一定的帮助 ；）</li></ul><p><strong>② 时间是不变的，但是单位时间内工作的价值是可以延长的，朴素点说，你应该让这个月写的代码在未来一个月甚至半年中都能产生价值</strong>，对应的策略是：</p><ul><li>有意识地提升自己的抽象能力，挖掘可复用的内容；在工作过程中，不断沉淀可复用的脚本、组件、模块等；</li><li>将自己能力的提升计划，适当强插到公司因素问题的解决过程中，比如你想了解某个框架的使用，做项目的时候就用这个框架好了，不要因为你不懂这个框架而担心项目做不完，毕竟成长本身就是需要付出点时间成本的。</li></ul><p>当你把这两块做好了以后，当你能够驾驭当前的工作之时，你就是高级工程师了。</p><hr><p>本文来源：在「<a href="https://t.zsxq.com/aMfUrVJ" target="_blank" rel="noopener">技术和业务思源地</a>」的交流和答疑。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/06/09/growth-in-startup/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[聊聊测试]]></title>
      <link>http://www.barretlee.com/blog/2019/05/30/microservice-design-about-testing/</link>
      <guid>http://www.barretlee.com/blog/2019/05/30/microservice-design-about-testing/</guid>
      <pubDate>Thu May 30 2019 00:02:20 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>看《微服务设计》一书的测试章节，有一些想法，记录下。</p><h3 id="测试分类象限图"><a href="#测试分类象限图" class="headerlink" title="测试分类象限图"></a>测试分类象限图</h3><p>为保证业务的质量和稳定性，一般会进行诸多测试，测试有很多类型，大致可以归类为：</p><ul><li>验证是否实现了功能（验收测试）</li><li>验证是否正确实现了功能（单元测试）</li><li>对产品可用性做测试，如响应时间、性能、安全等（非功能性测试）</li></ul><p><img src="/blogimgs/2019/05/30/测试象限分类图.png" alt="upload successful"></p><p>我们平时会写两类代码，一种是基础类代码，一种是业务类代码，前者更多的是面向团队，后者更多的是面向产品。</p><p>面向产品的代码主要是业务逻辑，大多数情况会在验收环节进行验证，这一环可以通过自动化+人工测试保障，实际情况更多还是人工测试，编写 UI 测试用例的成本是极高的，而且在业务迭代快的情况下，根本来不及写测试用例，还不如人工回归；而面向团队的代码通用性较强，功能模块的隔离性做的也比较好，就需要比较多的单元测试来保障了。</p><p>除了验收测试和单元测试，还有一类是面向产品体验的非功能性测试，如性能、响应时间、安全等，这类测试在 2C 的产品中要求得比较多，一般会通过工具来保障，如页面上线时进行真机测试、渗透测试和压力测试等。</p><p>非功能性测试往往会有一个很麻烦的问题：非功能性问题多样性强、差异化大，测试平台难以良好的满足平台用户的测试诉求。一般而言，测试平台需要平台方与开发者共建，平台提供机制，开发者贡献规则和套件。</p><h3 id="测试的覆盖范围"><a href="#测试的覆盖范围" class="headerlink" title="测试的覆盖范围"></a>测试的覆盖范围</h3><p>从测试的覆盖范围来看，可以将测试分为三类：</p><ul><li>函数块的功能测试，不会启动服务（单元测试）</li><li>绕开用户界面，直接对服务调用测试（服务测试）</li><li>打开用户界面进行测试（端对端测试）</li></ul><p>单元测试覆盖的只是一个小的代码片段；服务测试则可能会依赖一连串的代码，甚至会依赖其他系统的服务；端对端的测试，通过时会让人十分放心，因为这类测试会覆盖大量的系统代码。</p><p>在合作的时候，会发现一个十分有意思的现象，很多开发者不愿意写单元测试，几乎每次发布之前，都是将代码提交到预发布环境，让前置依赖方通过端对端测试或者服务测试来验证服务的准确性和稳定性。这带来的问题是什么呢？</p><ul><li>端对端测试容易忽略细节，一旦测试用例不够全面，系统的安全和稳定性将会有很大的挑战；</li><li>端对端测试周期和反馈周期都特别漫长，一次测试需要经过多层系统或者多次函数调用才能触发问题；</li><li>端上的很多操作会触发很多重复的底层代码测试，影响测试效率；</li><li>由于环境的限制，少部分的端对端测试无法进行等；</li></ul><p>问题还有很多，就不一一列举了。如果你的服务会被多个系统调用，或者会被大量的用户使用，我建议你多写测试用例，不要总是依托于上游调用方给你反馈异常，尤其是作为基础服务的时候。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/05/30/microservice-design-about-testing/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[游记 · 内蒙古银肯响沙湾]]></title>
      <link>http://www.barretlee.com/blog/2019/05/29/traveling-in-the-desert/</link>
      <guid>http://www.barretlee.com/blog/2019/05/29/traveling-in-the-desert/</guid>
      <pubDate>Wed May 29 2019 15:37:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>上周四跟着团队去内蒙古玩了几天，对于一个南方人来说，北方处处都散发着迷人的风味。</p><p>本来规划是去草原，据有效情报，这个季节草原上的草还没有完全长起来，除了一堆粪便，没有几个有意思的项目，加上蒙古包里的饮食水平也还停留在「维持生命」阶段，综合考虑，最终决定去沙漠里浪几天，也算是工作之余挖掘些新鲜和刺激。</p><p>本文不算一篇游记，主要想说一下，去沙漠会遇到几个有意思的东西，以及需要准备些什么。</p><h3 id="响沙湾"><a href="#响沙湾" class="headerlink" title="响沙湾"></a>响沙湾</h3><p>我们去的地方叫做「银肯响沙湾」，是一个私人承包的 5A 级景区，面积不算大，是大沙漠的一处边界位置，在地图上看过去也就是一个小点。别的地方都在防止沙漠化，而银肯响沙湾则是经常除草，防止沙漠面积减小，足见其迷你。</p><p><img src="/blogimgs/2019/05/29/响沙湾-骆驼.png" alt="upload successful"></p><h3 id="沙漠暴雨"><a href="#沙漠暴雨" class="headerlink" title="沙漠暴雨"></a>沙漠暴雨</h3><p>响沙湾中央坐落着一家别致的酒店，酒店附近有两处沙地，一个叫做先沙岛，都是些比较刺激的娱乐项目，另一个叫做悦沙岛，适合玩累了以后看看表演、沐浴阳光。</p><p><img src="/blogimgs/2019/05/29/响沙湾-缆车.png" alt="upload successful"></p><p>可以坐缆车从沙漠外围直达莲花酒店，不巧的是，刚下缆车，一阵狂风骤雨下了起来，猛烈到什么程度呢？伞是不能打的，身体轻一点能把你吹倒咯。<strong>所以去沙漠，轻薄雨衣是必不可少的。</strong></p><h3 id="瞬间转晴，烈日当空"><a href="#瞬间转晴，烈日当空" class="headerlink" title="瞬间转晴，烈日当空"></a>瞬间转晴，烈日当空</h3><p>五六月份去银肯响沙湾，昼夜温差还是比较大的，高的时候 32° 左右，低的时候 10° 左右，由于不是沙漠腹地，极高和极低都不会那么夸张，带上<strong>一件小外套</strong>也就够了，对于有点脂肪的朋友，一件防晒衣估计也够了。酒店条件与我们平时住的都差不多，该有的都有。</p><p><img src="/blogimgs/2019/05/29/响沙湾-烈日.png" alt="upload successful"></p><p>防晒霜带不带我觉得问题都不大，因为我相信你进入沙漠以后，一定会把自己裹得严严实实，有<strong>帽子、魔术方巾、防晒衣、长裤</strong>等等。</p><h3 id="滑沙-amp-爬沙"><a href="#滑沙-amp-爬沙" class="headerlink" title="滑沙&amp;爬沙"></a>滑沙&amp;爬沙</h3><p>去之前我在迪卡侬买了一个登山用的<strong>多功能小背包，里面有一个 2L 的水袋</strong>，露着一根长长的吸管，喝水尤为方便，不过现在想想，由于没有深入沙漠，双手也都空着，背个书包就够了。</p><p><img src="/blogimgs/2019/05/29/响沙湾-爬沙.png" alt="upload successful"></p><p>滑沙这个项目还是比较有意思的，坐在一块长方形的木板上，从几十米高、坡度约摸 75° 的沙顶滑下来，双手不离开沙面，自己控制下滑的速度，可惜只玩了一次，接着玩需要自己爬上去，太高太陡人还多，就算了。</p><p>不少同学的手表、手机都遭了罪，沙漠的沙子非常细，除非是运动手表，一般的手表和手机都会有沙子伸进去，结果就是手机充电口插不进线，或者手表里有看得见的沙。所以，<strong>你的裤子和衣服一定要有拉链，在滑沙的时候也建议你带上手套</strong>。</p><h3 id="沙漠徒步"><a href="#沙漠徒步" class="headerlink" title="沙漠徒步"></a>沙漠徒步</h3><p>最期待的一个活动是沙漠徒步，走过了三个沙丘和一个大沙丘，从大沙丘滑下来的时候，听沙响，轰隆隆的声音，像是什么东西要从地底下钻出来似的，特别有意思的一个自然现象，这也正是“响沙湾”的来由。</p><p><img src="/blogimgs/2019/05/29/响沙湾-骆驼2.png" alt="upload successful"></p><p>徒步之前，我们穿好了酒店提供的<strong>沙漠鞋套，这个你不用买，</strong>，没有鞋套，沙丘上一脚踩下去，估计会进一鞋的沙，你可以打赤脚，据说很舒服，但是也有风险，有些动植物是有毒的，一不小心就会弄个奇痒无比。即使带了鞋套，回来的时候鞋子里也进了不少沙子，还是太细了。</p><p>来回说有五公里，实则也就三公里的样子，但是好几个伙伴已经累到不行，甚至还有一个已经中暑，幸好我带了<strong>两根登山杖</strong>，在上下沙丘的时候给我省了不少气力，去之前也喝了<strong>两瓶藿香正气水</strong>。</p><h3 id="念头"><a href="#念头" class="headerlink" title="念头"></a>念头</h3><p>内蒙之行给我的印象还是挺深刻的，第一天在呼和浩特市区，一个蒙古包里，吃着羊肉，看着表演；第二天和第三天呆在鄂尔多斯的银肯响沙湾；最后一天又回到了市区，吃吃逛逛。回来的时候，嘴皮子已经干裂到快出血了，建议朋友们带上一支好的<strong>润唇膏</strong>。</p><p><img src="/blogimgs/2019/05/29/响沙湾-念头.png" alt="upload successful"></p><p>银肯响沙湾，等孩子大点了，应该还会去一趟，带着家人一起在这被驯化的沙漠里玩一玩。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/05/29/traveling-in-the-desert/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[团队周会怎么开？]]></title>
      <link>http://www.barretlee.com/blog/2019/05/21/weekly-report/</link>
      <guid>http://www.barretlee.com/blog/2019/05/21/weekly-report/</guid>
      <pubDate>Tue May 21 2019 00:40:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote><p>这是一篇两年前未发表的旧文，公开发表下。</p></blockquote><p>给大家分享一下，周会怎么开，主要涉及形式和内容，个人见解，欢迎讨论。</p><p>在淘宝三年，待过的小团队有五六个，有两个团队不开周会，其他几个团队每周一次，形式不一。有一些效果不错，但也不可避免的，有些团队里头，周会只是个形式，汇报下工作就结束了。</p><p>一个团队，规模大小，有 3~5 人，也有 5~10 人，一个 Leader 带超过 10 人的团队，其实是不常见的，不是 Leader 能力不行，而是没办法把精力分散到太多人身上，一般超过 20 人的团队，都会分成两到三个小 Team，Team Leader 向团队 Leader 汇报。</p><h3 id="团队规模不同，周会的开展形式也会不太一样。"><a href="#团队规模不同，周会的开展形式也会不太一样。" class="headerlink" title="团队规模不同，周会的开展形式也会不太一样。"></a>团队规模不同，周会的开展形式也会不太一样。</h3><p>3~5 人的团队，可能平时吃饭就在一起，任何事情都有很多机会交流，Leader 和成员之间很容易融入，那么周会可能真的就是个形式，我待过的不开周会的团队，要不是因为团队规模太小，要不是因为团队成员能力都很强，特别主动，根本不需要开周会。</p><p>5~10 人的团队，周会形式可能会丰富许多，毕竟大家做的事情还是存在差异的，比如业务上的差异、工程上的差异、技术原理上的差异等等。如果仅仅是工作上的汇报，很多同学可能根本就不会去关注其他人的进展，结果就是底下汇报，就 Leader 一人在听，剩下的人埋头干着其他的事情。所以，往往人多的团队，会产出比较丰富的周会形式。</p><h3 id="那么，周会上，需要把握好哪些事情呢？"><a href="#那么，周会上，需要把握好哪些事情呢？" class="headerlink" title="那么，周会上，需要把握好哪些事情呢？"></a>那么，周会上，需要把握好哪些事情呢？</h3><p>作为一个 Leader，如果手下人员比较多，而且自己也有很多艰巨的任务在身，那么他会相当珍惜周会时间，毕竟这可能是他了解团队整体情况的少数渠道之一，这个时候，他会特别关注每个同学手里头的项目进度、问题、风险以及在项目中的想法和思考，在周会沟通中，也主要就是这么几个点。这种形式久了之后，就会感觉，周会便是念周报，无趣的很。</p><p>周会，一周就那么一次，一次也就 2 个小时左右（人多的话，大概一个下午），时间并不长，它做不了很多事情，工作汇报是关键点，但是汇报不应该是周会的全部。</p><h4 id="一、站在-Leader-角度"><a href="#一、站在-Leader-角度" class="headerlink" title="一、站在 Leader 角度"></a>一、站在 Leader 角度</h4><p><strong>1. 首先要把握好团队的健康程度，比如每个项目存在的问题和风险，团队成员的情绪问题、加班情况，所有人员的时间投入占比等。</strong></p><p>项目的细节问题可以通过周报或者在日常沟通中去了解清楚，周会上主要暴露出项目中已知或者未知的风险，已知的风险一定需要一个具体可实施的对策，这个对策可以是当事人给出的，也可以是大家群策群力想出来的，提前预判风险，可以让一个项目良好地进行。其他细节问题，不应该花太多时间在周会上，除非这些点能够让人有所启发，或者是大家的共性问题。</p><p><strong>2. 做好信息的「向下传递」。</strong></p><p>汇报是从下而上的消息传递路径，而自上而下的消息传递也相当重要。需要让小组成员了解整个团队的规划和目标，实时同步目标的微调和变化，分享周边团队的工作内容等。上下目标越一致，整个团队的生态越健康。</p><p><strong>3. 帮助团队成员深入到业务，技术是为产品服务的，只有把产品理解透彻了，才能够恰如其分地用好技术。</strong></p><p>在一群人面前讲话的机会并不多，周会就是一个很好的场景，让团队同学给所有人分享产品的规划，一方面是给他机会说话，一方面也可以让更多的人了解团队正在做的事情。不论是技术产品还是业务产品，最好能够在团队中做到一个主力、一个副手，副手位是业务的备胎，更是一种让团队成员涉及更广的场景的渠道。带领团队成员讨论产品细节，以及如何提前在技术上为产品的发展布局。</p><p><strong>4. 每次准备一个话题，收集问题、看法和想法。</strong></p><p>针对团队中出现的一些问题、场景，或者社区热门的事件等，准备一个话题，让每个人发表看法，回答团队的疑问，收集团队的想法，给出最后的总结。</p><h4 id="二、站在团队成员的角度"><a href="#二、站在团队成员的角度" class="headerlink" title="二、站在团队成员的角度"></a>二、站在团队成员的角度</h4><p><strong>1. 及时抛出问题和方案，及时寻求支援。</strong></p><p>有些问题的沟通是需要你一句我一句的沟通才能说清楚的，周报上没说，就一定要在周会上沟通清楚，把问题的背景交代清楚，遇到的问题和自己思考的方案先抛出来，让周会上所有的人集思广益，收集好的点子，带到日常的开发中去。如果在排期上存在风险，要及时的提出来，向主管寻求支援。</p><p><strong>2. 每次输出一个知识点。</strong></p><p>准备一些有思考的或者有技术含量的分享，5~10 分钟。把一个技术点、业务中遇到的问题、某个工具的使用或者产品的架构等等，分享给小伙伴。提前准备几页 PPT，说透。</p><p><strong>3. 了解团队的动向，调整自己的时间分配</strong></p><p>业务上的「技术含量」可能不高，一般每个同学都会在业务之外干点团队或者个人的项目，比如做一个调试平台、接口中心、测试工具等等。从大团队和小组中不断收集反馈，记下有启发的点子，寻找可以合作和技术推广的渠道。把时间聚焦到团队最紧迫的地方。</p><h3 id="周会形式"><a href="#周会形式" class="headerlink" title="周会形式"></a>周会形式</h3><p>之前有个 Leader 从来不开周会，其实感觉也挺爽的，没啥不好，主要还是因为团队成员自觉性很高，遇到的问题基本上都在平时沟通掉了，很少存在拖拉的情况。</p><p>还有一个 Leader，刚开始不开周会，后来觉得不太好，于是，每周五中午请小组吃饭，边吃边汇报，这种感觉就更爽了，我们一般挑最贵的点。</p><p>有一个 Leader，周会很准时，但是开得特别短（也可能很长…），前半段是向上反馈，问题和风险；后半段是向下反馈，变化和调整；剩下的时间是产品发展讨论，以及排期设定。最长的一次周会开了 7 个小时，开到半夜两点多…那是因为整个团队投入在一个项目中，基本上就属于项目沟通了。</p><p>有一个 Leader，喜欢把我们拖到项目室，水果、零食伺候，谈什么都行。</p><p>总之，怎么爽怎么来。周会的目的之一就是增进团队的感情。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/05/21/weekly-report/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[读《OKR 工作法》]]></title>
      <link>http://www.barretlee.com/blog/2019/05/16/book-reading-about-okr-working-methods/</link>
      <guid>http://www.barretlee.com/blog/2019/05/16/book-reading-about-okr-working-methods/</guid>
      <pubDate>Thu May 16 2019 08:03:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>花了两天功夫把 <a href="https://www.amazon.cn/dp/B07577T3XS/ref=sr_1_1?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&amp;keywords=okr%E5%B7%A5%E4%BD%9C%E6%B3%95&amp;qid=1557965131&amp;s=gateway&amp;sr=8-1" target="_blank" rel="noopener">《OKR 工作法》</a> 读了一遍，有一点收获，稍微记录下所思所想。</p><p><img src="/blogimgs/2019/05/16/book-OKR.png" alt="upload successful"></p><p>这本书内容并不多，前面几章通过一个创业故事让读者对 OKR 有一个整体的体感，后面两个章节，详细讲了 OKR 中 O 和 KR 具体的场景，应对的策略和背后的思考。</p><p>笔者在阿里巴巴工作，厂里推行的是 KPI 绩效考核制度，与 OKR 的理念还是有挺大的差异。两者都是目标实现的管理工具，前者不仅会帮助管理目标，而且会与薪资、晋升等挂钩，这就导致了，践行 OKR 的公司员工会更加注重公司/团队的目标实现，而践行 KPI 的公司员工会更加注重如何保质保量地完成个人目标。既然是管理工具，自然得看管理者能不能用好；两者都有各自的应用场景，没有好坏之分。</p><p>由于之前对 OKR 了解不多，仅靠读一本书也难以达到深入理解的状态，后续一年，我会通过 <a href="https://worktile.com" target="_blank" rel="noopener">worktile</a> 提供的目标管理工具进行一年的家庭&amp;个人目标管理，以此来熟悉 OKR 工作法。</p><p>OKR 是一套定义和跟踪目标及其完成情况的管理方法，大致是：</p><ol><li>首先需要制定一个为期至少 3 月鼓舞人心的目标（Objective）</li><li>针对目标思考几个关键结果（Key Result），用于衡量效果</li><li>确定好本周需要推进的事项，以及其优先级，每周 review 目标和关键结果</li><li>确定好未来 1 月需要推进的事项</li></ol><p>从上面的几点可以感受到，OKR 一直在帮助践行者聚焦目标，帮助监督所做的每一件事情都对目标有帮助，将最能够触达目标的事情优先级提到最高。下面解释下为什么要这样做，以及这样做为什么会取得好的结果。</p><h3 id="目标的设定"><a href="#目标的设定" class="headerlink" title="目标的设定"></a>目标的设定</h3><p><strong>目标的设定一定要鼓舞人心</strong>，OKR 工作法中提到了一个自信指数，如果你有 100% 把握完成目标，说明这个目标门槛太低了；如果信心指数低于 50%，那么实施起来压力会特别大，过程中遇到一点阻碍，可能就放弃了；70% 是一个很好的阈值，即基本上可以达到目标但又会有一点挑战。自信指数是随着时间的推移不断变化的，每周都要重新调整。</p><p>另外，<strong>目标不宜过短</strong>，一两周就能完成的工作，那个不能叫做目标，最多是个任务。周期最好是一个季度以上。</p><p>在设定目标之前，一定需要<strong>为全员灌输长期的使命</strong>，这个使命至少可以维持 3~5 年，比如阿里巴巴的使命是“让天下没有难做的生意”，谷歌的使命是“整合全球信息，使人人皆可访问和收益”等等。有了长期的使命，每个阶段所拟定的目标就不会有大的偏差。</p><p>除非有好几个互不相交的方向，否则目标有一个就行了，<strong>不要太多</strong>。</p><h3 id="关键结果"><a href="#关键结果" class="headerlink" title="关键结果"></a>关键结果</h3><p>关键结果是用来衡量目标的，一定要反复对焦目标来确定 3~4 个关键结果，确保关键结果是可以支撑实现目标的，正向推导、反向演绎等，通过多种方式确保关键结果的拟定准确性，这个过程一般需要多轮对焦和辩论。</p><p>若你看到关键结果内心有点小激动或小彷徨，那就对了，需要有点挑战才能拿到符合预期的目标结果。</p><p><strong>关键结果应该是可衡量的</strong>，最好遵循 <a href="https://en.wikipedia.org/wiki/SMART_criteria" target="_blank" rel="noopener">SMART</a> 原则来制定。</p><h3 id="过程监督"><a href="#过程监督" class="headerlink" title="过程监督"></a>过程监督</h3><p><strong>OKR 的意义不仅仅在于完成目标，更重要的是帮助团队挖掘真正的实力</strong>。在每周的进度跟进会上，不应该把所做的事情当做汇报和考核结果来呈现，应该通过反复的对焦，确定所做的事情是对目标有意义的，对目标有推进作用的。</p><p>在 OKR 践行过程中，要确保短期和中长期要做的事情，不断调整和确认优先级，以确保整个团队的信心指数是在持续提升的。过程中需要及时处理风险和问题，以防出现过大的偏差。</p><p>通过一个阶段（季度）的实践，基本可以摸索出团队的综合实力，对比阶段开始前设定的目标和团队拿到的结果，可以看出团队是否故意隐藏了实力，或者是否目标设置得过高，在下一个阶段作出合适调整。一方面，可以更好的完成目标，另一方面，不断的挖掘、培养和提升团队的综合实力。</p><hr><p>后续将用一年时间来感受下 OKR，希望一年以后可以有更深的感悟。</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/05/16/book-reading-about-okr-working-methods/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[《组织行为学》学习笔记]]></title>
      <link>http://www.barretlee.com/blog/2019/05/12/organizational-behavior-study-notes/</link>
      <guid>http://www.barretlee.com/blog/2019/05/12/organizational-behavior-study-notes/</guid>
      <pubDate>Sun May 12 2019 00:44:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote><p>在得到上学习李育辉老师的<a href="https://m.igetget.com/share/course/pay/detail/36/46" target="_blank" rel="noopener">《组织行为学》</a>课程，每个章节都做了点笔记，单纯看笔记一点体感都没有，感兴趣的同学可以结合<a href="https://m.igetget.com/share/course/pay/detail/36/46" target="_blank" rel="noopener">课程中</a>生动的例子进行学习和理解。</p></blockquote><p>生物操心的事情：</p><ul><li>细胞自身成长和代谢</li><li>细胞之间的协作</li><li>与外部环境互动</li></ul><p><strong>组织行为学是研究个体规律、个体之间的关系，以及大结构对组织的影响，</strong></p><ul><li><strong>立场：公司</strong>。以组织为导向的学科，将组织的利益放在第一位；满足企业自身利益，再兼顾个体需求和社会需求，才能良好地达到三赢。</li><li><strong>研究方法</strong><ul><li>经验主义学派：计划、组织、指挥、协调、控制。强调抽象、简洁、普世。</li><li>实证主义学派：做实验！追求复杂、多元、有条件限制的结论。</li></ul></li><li><strong>基本观点：权变</strong>。因时而变，因势而变。</li></ul><style>.post-content hr{border-top:1px dashed #ccc!important;height:0!important;background:0 0!important}.post-content blockquote p{white-space:normal!important}</style><hr><h3 id="一、激发个体"><a href="#一、激发个体" class="headerlink" title="一、激发个体"></a>一、激发个体</h3><p>人是复杂的。不要把人看成只考虑经济利益、可以被简单操控的乌合之众。</p><p>　　↑</p><p><strong>人的底色可变</strong>，多元性、复杂性，人格、情绪、角色的变化。招聘需要注意，什么靠挑选，什么反而可以靠培养。</p><hr><h4 id="个性"><a href="#个性" class="headerlink" title="个性"></a>个性</h4><p>情景强度：迫使个体人格改变的第一要素，不是情景有多复杂，也不是持续的时间，而是<strong>强度</strong>。</p><ul><li><strong>明确性</strong>，清晰、明确、单一的工作</li><li><strong>一致性</strong>，指令相互兼容</li><li><strong>约束性</strong>，限制个体自由</li><li><strong>严重性</strong>，个体行为的后果</li></ul><hr><h4 id="情绪"><a href="#情绪" class="headerlink" title="情绪"></a>情绪</h4><p>资源保存理论：<strong>情绪是一种资源</strong>，需要补充。每个人的情绪资源都是有限的。资源缺失时，潜意识会将其当做威胁；缺失太快，身体会作出反应避免损失。</p><ul><li>场景没有发生改变，导致消耗快</li><li>情绪反馈路径缺失，导致补充少</li></ul><p>补充情绪资源的路径：</p><ul><li>生理资源互补，如健身、睡觉</li><li>强迫大脑跳出目前的情景，如冥想</li><li>用亲密关系来补充，比如爱情</li></ul><hr><h4 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h4><p>传统的动机理论都是默认组织是工作任务的主人公，而员工是配角：</p><ul><li><strong>双因素理论</strong>，公司的奖励手段：<ul><li>保健因素：薪酬、工作环境、同事关系等</li><li>激励因素：晋升机会、对个体的尊重等</li></ul></li><li><strong>需求理论</strong>，成就、权利、对群体的归属感等。</li></ul><p>当代动机理论，员工要成为工作的主角（自我掌控）：<strong>当那些能让自己乐在其中的任务变成一种义务的时候，个体的动机就会被破坏。</strong></p><ul><li>自我一致性</li><li>目标设置理论，KPI 更像是组织强加，OKR 像是自我目标驱动</li></ul><p>将员工当做投资对象来看待。如建立 OK 合伙人机制，O 为 小 CEO，K 为 小 CTO。</p><hr><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>工作和生活，两个角色扮演带来的冲突问题解决：</p><ul><li>不要用工作时间划定界限<ul><li>在特殊的社会时期，时间和劳动成果是划等号的</li><li>如今的知识经济时代，用时间评估成果越来越难</li><li>工作以任务为基本单元，而时间只是任务的一个要素</li></ul></li><li>角色理论<ul><li>不同场景中扮演的不同角色会引导出不同的反应</li><li>角色的转换会消耗认知能量</li><li>一个人在工作和生活中扮演的角色不一样，但是经常因为没有及时切换而发生重叠</li></ul></li><li>角色管理<ul><li>工作分清主次，主要工作在工作时间内完成，非主要工作，员工次要时间处理</li><li>设置统一的交流时间，根据时间集中度来分离员工角色</li><li>帮助个体减少他承担家庭角色的压力</li></ul></li></ul><hr><h4 id="组织承诺到职业承诺的转变"><a href="#组织承诺到职业承诺的转变" class="headerlink" title="组织承诺到职业承诺的转变"></a>组织承诺到职业承诺的转变</h4><p><strong>组织承诺</strong>是员工贡献给组织的忠诚度，是企业千方百计想要从优秀员工那里争取到的东西。</p><p>现在，每个人虽然笔头上是和公司签合同，但是心里却是和自己的职业签。因为不放心组织，所以要给自己选择一条职业发展的塞到，然后把未来寄托在它身上。这是<strong>职业承诺</strong>。</p><p>对于优秀的员工：</p><ul><li>通过制度保障员工的自我突破</li><li>越是优秀的人，越在乎自己正在和谁共事，越是在乎自己能不能从其他人身上学到东西</li><li>鼓励员工走出公司，走进世界</li></ul><p><strong>核心在于鼓励员工在工作中遇见“未知数”，目的是让他们成长</strong>。</p><p>从长期来看，优秀的员工只忠于职业，而不是忠于企业，所以企业必须要转变思路，让自己成为商品。对个体的职业发展服务。</p><hr><h4 id="深度的激励措施"><a href="#深度的激励措施" class="headerlink" title="深度的激励措施"></a>深度的激励措施</h4><p>常规激励手段失效后的措施：</p><ul><li>把荣誉颁发到员工家中</li><li>工作嵌入，如将影响力扩展到员工的社区和家庭，给他们带来额外的利益</li><li>为员工打造外部关系网，如员工家属福利，涵盖医疗、教育、社会福利保障等</li></ul><hr><h4 id="彩虹理论"><a href="#彩虹理论" class="headerlink" title="彩虹理论"></a>彩虹理论</h4><p><strong>中国劳动力成本持续走高的趋势，短期内不会改变。</strong></p><p>彩虹理论：人的一生可概括为一条彩虹，彩虹有两个维度，一个是掺毒，也就是我们的年龄，另一个是宽度，也就是我们生活的广度。</p><ul><li>一个人扮演几个不同的角色比扮演相似的角色有更多的满足感</li><li>总有一个角色是相对重要的，称之为“显著角色”</li><li>当一个角色从个体身上剥离的时候，称之为“角色退出”</li><li>为了填补确实的满足感，个体会寻找并且加强新的“显著角色”</li></ul><p>如果把人力当做资源，每个年龄段的员工，都有他可以被利用的价值，即便是 60+ 的老年阶段。</p><hr><h3 id="二、领导团队"><a href="#二、领导团队" class="headerlink" title="二、领导团队"></a>二、领导团队</h3><p>领导力不仅仅是团队领导者的个人特质，更是一种存在于他和成员之间的互动关系。</p><ul><li>招到人</li><li>争取信任，建立默契</li><li>做好决策</li></ul><hr><h4 id="招人"><a href="#招人" class="headerlink" title="招人"></a>招人</h4><p>岗位正在变得越来越复合，清晰描述越来越困难。<strong>人-岗匹配</strong>，组织将个体特征，通常是能力和经验，与工作岗位的要求进行匹配，来确定合适的人选。</p><ul><li><strong>人-人匹配</strong>，不描述岗位而是描述优秀个体</li><li><strong>角色匹配</strong>，考察应聘者能否承担好相应的团队角色。实干家、创新者、协调者、熟虑者等</li><li><strong>潜力匹配</strong>，高绩效并不等于高潜力，判断维度：<ul><li>学习的积极性</li><li>眼界的宽度，完整的知识结构</li><li>理解他人，共情</li><li>成熟度</li></ul></li></ul><hr><h4 id="合群"><a href="#合群" class="headerlink" title="合群"></a>合群</h4><p><strong>非正式组织</strong>，在个体融于组织过程中，承担了重要的中间人作用。</p><p>互联网技术让建立非正式组织的成本降低了，这点可以充分利用起来。</p><hr><h4 id="领导力"><a href="#领导力" class="headerlink" title="领导力"></a>领导力</h4><p>追随者特立独行，愿意主动表达意见，甚至有点我行我素。自恋型人格崛起，原因：</p><ul><li>父母培养的教育理念，看重自尊心</li><li>贷款方便，经济条件制约力减弱</li><li>社会自我肯定的文化，如媒体节目，真人秀</li><li>社交媒体的便捷性，并提供了屏蔽和拉黑能力</li></ul><p>如何领导自恋型人格人群：</p><ul><li>让他们觉得你很厉害</li><li>让他们觉得自己很厉害</li></ul><p>领导者就需要让自己有缺陷，让团队成员感受到， leader 总体还行，但是也有搞不定的地方，得我来。<strong>暴露情绪，而非能力缺陷。</strong></p><hr><h4 id="凝聚力"><a href="#凝聚力" class="headerlink" title="凝聚力"></a>凝聚力</h4><ul><li>利用相对剥夺来提升团队凝聚力，领导者可以在待人的态度上做到有所区分；</li><li>一定要注意，剥夺的是自尊心等虚一点的东西，决不能和绩效有关；</li><li>剥夺也要讲究“公平”；</li><li>为了把负面效果降到最低，要给足团队成员必要的辅助与资源。</li></ul><hr><h4 id="决策"><a href="#决策" class="headerlink" title="决策"></a>决策</h4><p>“团体迷思”，团队成员太看重共识，以至于为了达成一致意见，会忽略决策目的，放弃某些事实，从而导致判断失误。几个表现：</p><ul><li>对自身的高估</li><li>封闭保守</li><li>寻求一致</li></ul><p>问题的核心出在果断团结身上，组织行为学提出的手段，围绕减少“内聚动力”展开：</p><ul><li>要让成员同时扮演批评性评估者的角色；设立唱反调的人</li><li>在同一个问题上设立若干独立的评估团队，每个团队在不同的领导者带动下单独商议，然后再汇总；引入外部视角</li><li>处于团队结构中心的任务，应该做到公正无私；弱化强势者</li></ul><hr><h3 id="三、重塑组织"><a href="#三、重塑组织" class="headerlink" title="三、重塑组织"></a>三、重塑组织</h3><p>组织行为学要探讨个体、群体、组织结构这三件事。先搭班子，再定战略，为何？</p><ul><li>现有的班子，不适合当前的战斗</li><li>边调整边干活，效果滞后，远水不解近渴</li></ul><p>组织就是很多很多小的领导力关系放在一起，组成的大领导力关系。形成一个稳定的、有战斗力的结构，一定需要时间，急不得。很多人事变更，牵一发而动全身。</p><hr><h4 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h4><p>传统的解决办法面临的挑战是组织规模限制，人数不能太多。去中心化首先需要找到节点人物，什么是节点人物：</p><ul><li>喜欢率先发起协作、组织讨论，但是不发表主宰性的一件，而是鼓励想法河流继续前进</li><li>善于分享外部的情报</li><li>擅长指定规则，总是保证推进的方向不发生严重偏离，而是为信息传递保驾护航</li></ul><p>如何简单找到节点人物：通过数据加权统计，看看个体在关键事件或者核心操作上执行的频度，比如收发邮件的次数、发起讨论的次数、指定规则的次数、创意加工的次数等等。</p><hr><h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>授权走样，一种情况是管的太细，一种情况是放任不管：</p><ul><li>是否规定职责边界？</li><li>是否提供了必要的辅导？</li><li>如果失败，风险和后果谁承担？</li></ul><p>加强心理授权：目标的内化、控制感和效能感。</p><p>授权走样的本质上都是犯了一个错误，就是组织把授权的目的搞错了。<strong>授权的对象不应该是事，而是培养下属，授权的对象应该是人。</strong></p><p><strong>如果你给了下属授权，反馈的就不应该是具体的做法，而是对他能力增长的评价。</strong></p><hr><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>冲突可以分为三类：</p><ul><li>任务冲突，任务本身的不合理</li><li>关系冲突，人际关系之间发生了问题</li><li>程序冲突，授权和角色发生了冲突</li></ul><p>以上<strong>只有关系冲突是恶性的，而且不易察觉，任务冲突、程序冲突都是在帮助组织发现问题</strong>。为了减少关系冲突产生的可能性，应该：</p><ul><li>公开化，并且制定详细、明确的处理程序</li><li>引入外部第三方来评判，给组织找个裁判</li><li>人为制造冲突，解决现有矛盾</li></ul><hr><h4 id="办公室政治"><a href="#办公室政治" class="headerlink" title="办公室政治"></a>办公室政治</h4><p><strong>办公室政治很难彻底根除，因为它不是组织与个人之间的矛盾，而是组织与资源之间的矛盾</strong>。也就是说，资源有限是办公室政治发生的本质原因。</p><ul><li>政治行为肯定会带来内耗，因为个人的经历，转移到了与工作无关的地方，他会对组织绩效产生负面影响</li><li>办公室政治无法避免，每个人最开始展开政治行为都是为了获得权力，服务于个人目标；管理者应该控制个人目标的比例，不能伤害组织的利益</li><li>管理办公室政治，最重要的是评估风险，缩短持续时间，说白了让他快点过去。领导者不能置身事外，杳然给自己变成最大的权利砝码</li><li>管理者应该通过沟通消解矛盾；如果不可消解，宁可激化矛盾后，选择其中一个</li><li>一定要做好善后工作，事后详细解释，避免集成员工错误归因和盲目模仿</li></ul><hr><h4 id="知识管理"><a href="#知识管理" class="headerlink" title="知识管理"></a>知识管理</h4><p>知识管理的几个问题：隐瞒、隐性知识、不同变通。</p><p>表面上，知识管理就是手机、储存、共享有价值的信息和经验。但是深层思考，目的还是为了方便员工学习，更好地解决问题。</p><ul><li>组织高频率、仪式感强的只是分享活动；</li><li>保证相关人员都参与，建立对他人知识结构的认知</li><li>帮助员工进行换位思考，理解他人行动背后的逻辑思维</li><li>格外重视关于失败、妥协、变通的经验分享</li></ul><hr><h3 id="四、书单推荐"><a href="#四、书单推荐" class="headerlink" title="四、书单推荐"></a>四、书单推荐</h3><ul><li>克里斯·阿基里斯《个性与组织》</li><li>弗雷德里克·莱卢《重塑组织》</li><li>罗恩和戴维联合写的《无边界组织》</li><li>《自由企业》</li><li>奥托·夏莫《U 型理论》</li></ul>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/05/12/organizational-behavior-study-notes/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[如何策略性投诉 10086，以减少电话骚扰的可能性]]></title>
      <link>http://www.barretlee.com/blog/2019/05/06/complaint-to-10086/</link>
      <guid>http://www.barretlee.com/blog/2019/05/06/complaint-to-10086/</guid>
      <pubDate>Mon May 06 2019 09:48:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>近期应该有不少人收到了如下短信，有来自中国移动的，也有来自中国联通的，</p><p><img src="/blogimgs/2019/05/06/10086-pm.png" alt="upload successful"></p><p>移动和联通会同时发出这条信息，十有八九是收到了工信部的要求，背后的缘由本文不做过多的猜测。笔者亦是备受各类营销推广类电话的骚扰，频繁时每天能接到三四个，萧条期也能隔三差五收到一两个。近期可能因为手机流量购买频繁，大约三四个月前开始，几乎每周都有来自中国移动（相关）公司的流量套餐推广电话，笔者怒了，打算与他们抗争到底，欲彻底断绝此类骚扰，故有了一段长达约一月的投诉史，积攒了些经验，分享给大家。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>期望通过此文，告诉普通群众几条常用的合法投诉渠道，以及在投诉过程中你可能会遇到的阻碍；另外也期望更多人看到此文后，行动起来，当一件事情成为高频出现的热点时，相关公司和相关部门才会将此事提到足够的优先级。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>先说说我持续投诉一个月的成果，我先后向移动公司 10086、工信部和市长热线几个渠道进行申诉，期间不断通过自媒体渠道披露申诉细节和申诉结果，最后 10086 的客服给我的承诺是：</p><ul><li>经理或以上级别员工向我电话或书面致歉</li><li>通知各个营业分部，将我的手机号码拉黑处理</li><li>历史骚扰，赔偿 100 元，以话费形式打款</li><li>未来每次骚扰我，补偿 50 元话费/次；对营业分部罚款 200 元/次</li></ul><p>以上是中国移动能够给我的承诺，和我个人申诉中提到的要求相差比较大，我个人的要求是：</p><ul><li>每次骚扰赔偿 100 元</li><li>历史骚扰加上投诉花费我的个人时间，按照我的时薪计算，赔偿我 1800 元</li><li>如可以保证未来无骚扰电话，则无需任何赔偿</li></ul><p>经过辗转多次的投诉后，已经有两三周没有收到骚扰电话了，所以我暂停了投诉，直到下次收到骚扰电话，我会采用法律手段维权。</p><h3 id="投诉阻碍"><a href="#投诉阻碍" class="headerlink" title="投诉阻碍"></a>投诉阻碍</h3><p>下面我来一一列举下，投诉过程遇到的“阻碍”和处理办法：</p><h4 id="1-首次拨打-10086，告知会给你在系统添加防骚扰标记"><a href="#1-首次拨打-10086，告知会给你在系统添加防骚扰标记" class="headerlink" title="1. 首次拨打 10086，告知会给你在系统添加防骚扰标记"></a>1. 首次拨打 10086，告知会给你在系统添加防骚扰标记</h4><p>10086 会维护一个名单列表，如果用户告知不允许 10086 拨打套餐推广类电话，则会被加入到这个名单，未来就不会有来自移动公司的骚扰了。</p><p><strong>官方的骚扰不会有，但是合作方的骚扰不会停。</strong></p><h4 id="2-再次拨打-10086，告知安装防骚扰软件"><a href="#2-再次拨打-10086，告知安装防骚扰软件" class="headerlink" title="2. 再次拨打 10086，告知安装防骚扰软件"></a>2. 再次拨打 10086，告知安装防骚扰软件</h4><p>为减少本次不必要的交涉，请早早地安装诸如 360 安全卫士、腾讯安全卫士之类的软件，并根据软件中关于防止骚扰的设置提示进行设置。</p><p>但一般此类软件只会对骚扰电话做标注，比如“外卖”、“出租车”、“保险推广”之类，有些号码不在软件的名单库中，则不会标注；并且这些软件并不会自动挂断骚扰电话，需要人肉挂断，不能真正起到防骚扰的效果。</p><p><strong>所以你就回复客服，软件安装了，没有效果。</strong></p><h4 id="3-再次拨打-10086，告知可设置屏蔽所有电话"><a href="#3-再次拨打-10086，告知可设置屏蔽所有电话" class="headerlink" title="3. 再次拨打 10086，告知可设置屏蔽所有电话"></a>3. 再次拨打 10086，告知可设置屏蔽所有电话</h4><p>这里的屏蔽所有电话指的是，10086 提供了一项服务，可以做到，任何电话打过来的时候，对方需要根据 10086 的语音提示输入四位安全验证码，对方输对了验证码，电话才会真正打到你的手机。</p><p>这个服务显然不适合我们，试想下，年迈的父母给你打电话，还得输个验证码？公司老板给你打电话，每次都让他输个验证码？</p><p><strong>所以你就回复客服，不开启这个功能</strong>，其实这个功能本身也不是为普通用户设计的。</p><h4 id="4-继续投诉-10086，却被告知不要相信非官方电话"><a href="#4-继续投诉-10086，却被告知不要相信非官方电话" class="headerlink" title="4. 继续投诉 10086，却被告知不要相信非官方电话"></a>4. 继续投诉 10086，却被告知不要相信非官方电话</h4><p>由于骚扰电话一般是营业厅的座机或者营业员的私人手机打过来的，非 10086 官方号码，所以客服会告诉你，不要相信此类电话，此类电话与中国移动公司无关。</p><p>很明显，他们在推卸责任对吧，你跟他拌嘴，他们会坚持告诉你，不要相信，不要相信，不要相信，怎么办？</p><p><strong>请通过骚扰电话直接购买套餐，销售员会让你提供通过 10086 发送的验证码，你可以勇敢地告诉他，然后你会发现你的套餐会立即变更，没关系，不着急。看下一步。</strong></p><p>注意：这里要注意了，一定是 10086 发过来的验证码才能相信，不排除诈骗电话的可能性。</p><h4 id="5-继续投诉-10086，并要求取消套餐，会被告知向上反馈"><a href="#5-继续投诉-10086，并要求取消套餐，会被告知向上反馈" class="headerlink" title="5. 继续投诉 10086，并要求取消套餐，会被告知向上反馈"></a>5. 继续投诉 10086，并要求取消套餐，会被告知向上反馈</h4><p>先让客服帮你查询套餐变更情况，确认套餐已经变更。</p><p>本次投诉，你告诉他，为了证明之前的骚扰电话与中国移动公司有关（你们客服说与你们无关），所以购买了套餐，请取消套餐变更，另外投诉这个销售员和移动公司：</p><ul><li>移动公司为何授权这个销售员通过 10086 发送短信</li><li>投诉移动公司（销售员）骚扰</li></ul><p>此时你就可以要求赔偿，骚扰了你，并浪费了你的时间，打扰了你的休息；且此事已经证明与移动公司有关，请移动公司不要再推卸责任。</p><p><strong>但是我不建议你此时索赔，因为你的目的是减少骚扰，请继续投诉，要求他们的上级领导给你回复，保证不再有类似的骚扰电话过来！</strong></p><p>期间你会多次收到来自 10086 的回电，告知无法给出承诺，并反复给出第 1、2、3、4 条方案来恶心你。</p><h4 id="6-向工信部-12300-投诉，请使用邮件投诉"><a href="#6-向工信部-12300-投诉，请使用邮件投诉" class="headerlink" title="6. 向工信部 12300 投诉，请使用邮件投诉"></a>6. 向工信部 12300 投诉，请使用邮件投诉</h4><p>先在网上找到你手机归属地所在的工信部邮箱（不同城市貌似不一样），然后详细地说明问题，要注意几点：</p><ul><li>我已经多次向 10086 申诉，无法解决电话骚扰问题</li><li>10086 不承认是他们公司打过来的电话，投诉移动公司泄露用户隐私数据给三方或合作伙伴</li><li>强烈要求赔偿，对，这一步索赔，<strong>索赔请找工信部，不要找 10086 客服</strong></li></ul><p>我给出一个投诉模板（见附录一），以供参考。</p><p><strong>一般三天内会有一个经理级别的客服通过 10086 给你回电，如果对方气场比较强大，你就记住一句话，“必须赔偿，并要求不再受到骚扰电话”。对方如果继续解释，就强调继续投诉中国移动违法泄露用户隐私数据，如泄露电话号码、历史消费记录等信息给非移动官方人员。</strong></p><p>此时不出意外，他们应该会提出我在「效果」章节中提到的方案。</p><p>注意：方案中的 50 元话费，他可能会说成「奖励」，移动公司奖励你的举报；此时，你不应该接受！这必须是赔偿，性质不一样。<strong>如果他非要说奖励，你可以回复，接受你们的奖励，但同时要求赔偿！</strong></p><p>如果没有谈妥，还可以向工信部申请调解，我给了一个调解模板（见附录二）。</p><h4 id="7-相信你仍然没有获得期望的结果，此时再通过市长热线投诉"><a href="#7-相信你仍然没有获得期望的结果，此时再通过市长热线投诉" class="headerlink" title="7. 相信你仍然没有获得期望的结果，此时再通过市长热线投诉"></a>7. 相信你仍然没有获得期望的结果，此时再通过市长热线投诉</h4><p>市长热线的投诉电话是 12345，你可以告知已经向客服投诉无果，向工信部投诉没有获得期望的结果。</p><p>有些城市的市长热线办事效率和效果还是不错的，可以在工信部投诉的同时或之后拨打。</p><p>如果移动公司一直推脱或表示无法承诺解决问题，你可以强烈要求将你在各个销售部或营业厅拉黑，既然移动公司可以对一个销售部进行处罚，那么当然也可以联系到所有的销售部或营业厅，将你拉黑。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>投诉是一件漫长的事情，不要不耐烦，当做一种乐趣便好了。</strong> 我希望通过此文，能够帮你争取到部分赔偿，同时更希望运营商和相关部门能够重视起这件事情。</p><p>其实，不仅仅是移动/联通的骚扰，其他类型，尤其是以 <code>95</code> 开头的骚扰电话，络绎不绝。我们可以先把矛头指向这些大公司，让相关部门引起重视，然后祈祷未来会变好…</p><hr><p><strong>附录一，向工信部 12300 的邮件申诉模板：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 申诉人信息</span><br><span class="line"></span><br><span class="line">姓名：XX</span><br><span class="line">电话：XXXXXXXX</span><br><span class="line">邮箱：XXXXXX@XXX.com</span><br><span class="line"></span><br><span class="line">## 申诉对象</span><br><span class="line"></span><br><span class="line">10086，移动公司</span><br><span class="line"></span><br><span class="line">## 问题描述</span><br><span class="line"></span><br><span class="line">1、[问题] 移动公司（或其合作部门）长期较高频率地打电话让用户更换/购买手机流量套餐，对我造成严重骚扰；</span><br><span class="line">2、[投诉] 多次向 10086 投诉（超过 5 次），客服说已经将我设置了「推广免打扰」的标记，他们的工作人员看到后，不会再给我打推广电话，然后每次都没有解决问题，依然有骚扰电话打过来；</span><br><span class="line">3、[回电] 10086 工号为 9583 以及另外一位客服回电说，电话不是官方打出来的，他们查不到推销人员的部门归属，无法帮我解决问题，且下次投诉依然是这个回复；</span><br><span class="line">4、[问题确认] 后来我通过电话为 1366****6378 自称王*云的销售人员购买了流量套餐，购买后向 10086 确认，发现套餐确已变更。那么这可以证明电话推广确系移动公司（或其合作部门）打出，确系为移动公司（或其合作部门）骚扰用户。</span><br><span class="line"></span><br><span class="line">## 投诉内容</span><br><span class="line"></span><br><span class="line">1、投诉移动公司电话骚扰用户</span><br><span class="line">2、投诉移动公司将我的个人信息泄露给三方（或其合作部门），让骚扰电话不断打过来</span><br><span class="line">3、投诉工号为 9583 的客服人员，不负责任</span><br><span class="line"></span><br><span class="line">## 期望结果</span><br><span class="line"></span><br><span class="line">1、未来不要让移动公司流量套餐相关的推广电话打进我的手机，如果有，期望移动公司以100元/次接听计费向我付费</span><br><span class="line">2、移动公司经理及以上级别领导向我电话或书面或官方微博道歉</span><br></pre></td></tr></table></figure><p><strong>附录二，调解模板</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 申请调解</span><br><span class="line"></span><br><span class="line">我的调解诉求是，如果中国移动公司不能承诺未来不给我打骚扰电话，我将要求赔偿，赔偿内容为：</span><br><span class="line"></span><br><span class="line">1. 历史骚扰次数（超过 8 次，算 8 次），每次 100 元的赔偿费（如果移动公司称之为奖励，我拒绝），800 元</span><br><span class="line">2. 按照我的平均时薪，赔偿我接听电话、投诉、查资料、收集证据等花费的时间，折算约 1000 元，如有需要，我可以提供工资证明和计算方法</span><br><span class="line"></span><br><span class="line">共计 1800 元，以中国移动公司的名义打入我的个人支付宝账户（与之前提供的电话号码一致）。如果可以承诺后续无骚扰电话，则无需赔偿。</span><br><span class="line"></span><br><span class="line">## 后续投诉</span><br><span class="line"></span><br><span class="line">赔偿后，未来骚扰次数若超过 5 次，我会继续投诉，继续要求赔偿。</span><br><span class="line">如果中国移动公司不接受我的诉求，我会采用法律手段维权；也会质疑和投诉 12300 作为监管部门的监管不力。</span><br><span class="line"></span><br><span class="line">## 给相关部门的建议</span><br><span class="line"></span><br><span class="line">建议参考国外 FTC（联邦贸易委员会）的策略，维护一份全国不愿接听销售电话的号码列表，当用户将号码注册进去以后，如果再有销售打电话过来即为违法，FTC 可对其处以每次电话最高 41484 美元的罚款，参考官网：https://www.donotcall.gov/</span><br></pre></td></tr></table></figure>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/05/06/complaint-to-10086/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[30 岁的焦虑和惆怅]]></title>
      <link>http://www.barretlee.com/blog/2019/05/04/30-years-old-coming-soon/</link>
      <guid>http://www.barretlee.com/blog/2019/05/04/30-years-old-coming-soon/</guid>
      <pubDate>Sat May 04 2019 23:23:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>本来已经爬到床上准备睡了，脑子里有几件事情萦绕不绝，想了想，还是起身写下点东西。或许可以随着键盘敲击的节奏，稍稍回忆下过去，反思下现在自己，展望一下未来。</p><h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><p>从大学开始，我就一直活在焦虑之中，为未来的不确定而焦虑，所以会经常习惯性地去考虑未来的事情；单身的时候想的是自己的，恋爱的时候想的是两个人的，生了娃以后想的是家庭的；不过，也可能是因为有了老婆的缘故，很多家庭相关的事情就不太愿意动脑子，大多都让老婆去想了；不过自己内心的那支焦虑之炬还从未熄火。</p><p>我生于 92 年，准确地说，现在是 26.5 岁，离 30 还有一段路程，可是这种似乎 30 岁男人比较常见的焦虑感时而浮现在我的内心（早熟么？），让我不得不好好反思和规划一下。</p><p>我比很多人要幸运，大二的时候就明确了自己的职业方向，所以大学里我便投入了许多精力专注于一个方向，那时也有幸加入了校内非常不错的技术团队，得到了几位优秀学长的指导（解答了我无数个为什么），技术上的实践很多；加上 13 年的时候在百度实习了几个月，让我对团队、业务这些学校触碰很少的概念有了比较清晰的印象；因此，在 14 年的阿里校招，我才能顺利地加入淘宝网。</p><p>印象中，大学里的我，是个比较内敛羞涩的男孩；后来也不知道是怎么锻炼出来的，不管对着什么人，遇到感兴趣的话题总能唠个不停，用我老婆的话说是“脸皮超级厚”。</p><h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><p>人生的几件大事，我超出父母预期给提前办好了，买房买车结婚生娃，如今爸妈只希望我能够稳稳当当地过好日子，可是我天生就不是“过日子”的人，持续六七年的焦虑前行，让我把焦虑当成了习惯，有的时候我会因为多玩了一把斗地主而感到愧疚…</p><p>这两年，我更加焦虑了。焦虑的原因很简单，因为我担心自己不能保持焦虑感，担心自己会松懈下来；这两年因为家庭、孩子等原因，让我的生活稍微放慢了一点，但“慢”这个姿势似乎与我是不兼容的，故而会出现标题中的“焦虑和惆怅”。</p><p>慢慢地，在适应。</p><p>好像很多时候，我们周遭的事情是无法被改变的，能改变的只有自己，让自己的兼容性变得更好，才能在复杂的环境中生存下来。</p><p>我的孩子一岁了，在过去的一年里，虽然我不是家里最累的，但也累的跟狗没啥两样。以前我的观点是，“娃是用来逗，娃是个有趣的东西”，那时果然太年轻，有了娃以后，才知道，“父母才是用来逗乐的”。孩子的成长需要父母的陪伴，“陪伴”这个词真的是意味深长，或许「父亲」这个身份，需要一辈子来适应吧…</p><p>在家里，因为孩子的缘故，我的地位已经下降了太多，因此，不想说太多。只能是，“痛，并快乐着”。工作方面，可能是我对自己的要求变得更高了，倒开始有些不满意起来。我很清楚自己想要什么，但也经常会迷失在前行的浓雾之中。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>马上工作的第五个年头就要到来，这也给了我第一次回头看五年的机会。五年时间，我变化了很多。想想过去的五年里我计划了的，达成了的，错过了的，再来盘算下未来五年，或许能够多一丝全盘掌控的底气。</p><p>我不知道未来会有哪些新的挑战和变化，先想几点我觉得需要变化或者达成的内容，摆放在这里，过几年再回来看看：</p><ul><li>掌握提升读书的效率和质量的方法；多读书，读好书</li><li>提升知识结构化程度；夯实基础，重塑技术架构</li><li>技术沉淀；在团队或者社区留下高质量的技术脚印</li><li>提升自我管理和团队管理技能；带领团队成功</li><li>提升英语；达到国外生活所需水平</li><li>找到旅游的乐趣；在国内外多留下脚印</li><li>降低“陪伴”的兼容性成本；成为孩子的朋友</li><li>发展至少一门爱好；找到乐趣，常年坚持</li><li>削减锐气，收敛剑锋；增加共赢的概率</li><li>拥有良好的身体；每年体检指标正常</li></ul><p>争取 30 岁的时候回首，能够少些焦虑和惆怅吧~</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/05/04/30-years-old-coming-soon/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[IT 管理岗面试热门问答 Top 30]]></title>
      <link>http://www.barretlee.com/blog/2019/04/23/top-30-it-manager-interview-qa/</link>
      <guid>http://www.barretlee.com/blog/2019/04/23/top-30-it-manager-interview-qa/</guid>
      <pubDate>Tue Apr 23 2019 22:44:00 GMT+0800 (China Standard Time)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote><p>原文地址：<a href="https://resources.infosecinstitute.com/top-30-information-technology-it-manager-interview-questions-and-answers-for-2019/" target="_blank" rel="noopener">Top 30 Information Technology (IT) Manager Interview Questions and Answers for 2019</a><br>原文时间：2019年3月7日<br>翻译计划：<a href="https://github.com/barretlee/translation-plan" target="_blank" rel="noopener">https://github.com/barretlee/translation-plan</a><br>翻译人员：<a href="https://www.barretlee.com/about/">小胡子哥</a></p></blockquote><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>IT 岗是一项富有变化且让人激动的挑战工作，它为一些人带来了管理机会。在你的职业生涯中，成为一名 IT 管理者会是一个重要的里程碑。</p><p>如果你和大多数人一样，在面试之前会有点紧张，那么，不妨看看我们汇总了一系列问题，它会帮助你在面试的时候避过雷区，同时我们也期望给你带来一些思考。IT 管理者融合了多重角色，面试时会有收到来自不同领域的灵魂拷问。我们收集了三十多个问题，归为如下三类：<strong>技术能力、管理技能和沟通技能</strong>。每一类都会帮你更好地理解 IT 管理者这个角色。</p><p>其中一些问题是管理方面的通用问题，另外一些侧重于 IT 技术领域，但是这两类问题对于这个角色都至关重要，所以如果你正准备面试，不妨好好看看这些问题，将会很有裨益。</p><h3 id="技术能力"><a href="#技术能力" class="headerlink" title="技术能力"></a>技术能力</h3><p>对面试官来说，判断你是否可以进入面试是一件很轻松的事情，他们只需要稍微撇一眼你的简历就行了。他们真正关心的是你在实际工作中，会如何处理技术挑战，如何让合适的人解决问题，以及是否会亲自处理一些问题。</p><p>对 IT 管理者来说，并非一定需要拥有技术背景，一些公司更看重 IT 部门的财务能力和监管能力，当然也非全部。这些 IT 管理者需要具备该领域的实践经验，以便他们能够在系统故障时正确处理，并对公司内部高管的问题做出适当的回应。</p><p>不同公司对 IT 管理者的要求是不一样的，中小型公司期望你在公司繁忙阶段干点实事、解决问题，而大型公司可能会分派给你非常具体的工作内容。面试时，技术方面的问题主要包括：你个人如何提升技能和自我学习，以及作为一个管理者应该如何提升自己等。</p><blockquote><p>下面十个问题都有一小段注解，因文章过长，未翻译</p></blockquote><ol><li>介绍你的技术背景，如有.</li><li>你会亲自处理技术问题么？</li><li>你倾向于将任务外包出去还是用来培养内部人才？</li><li>描述下你当前的角色.</li><li>你为 IT 部门创造了什么价值？</li><li>你如何看待员工自我提升和学习的问题？</li><li>你认为提升员工的能力是你的责任还是他们自己的责任？</li><li>你如何衡量部门的技术表现？</li><li>你从当前的雇主那里有学到哪些管理经验？</li><li>你有项目管理的经验么？</li></ol><h3 id="管理问题"><a href="#管理问题" class="headerlink" title="管理问题"></a>管理问题</h3><p>作为 IT 管理者的很大一部分工作就是管理人和资源，这一章节将聚焦在这两个方面。每个人的管理风格都不太一样，所以如果你没有按照下文所述的内容去执行也不用担心，仅供辅助思考。</p><blockquote><p>下面十个问题都有一小段注解，因文章过长，未翻译</p></blockquote><ol start="11"><li>你觉得担任 IT 经理最重要的职能是什么？</li><li>你如何处理工作中的失误？</li><li>你能给我们公司带来的最有价值的贡献是什么？</li><li>你做 IT 管理有多长时间了，你管理过多少人？</li><li>说说你带过的几个技术项目.</li><li>形容下你的管理风格.</li><li>如何看待你近十年的履历.</li><li>员工不符合预期，处理他们的最佳办法是？</li><li>当团队出问题的时候，你如何激励你的团队？</li><li>你是否对属下有过负面反馈，是否辞退过员工？</li></ol><h3 id="沟通问题"><a href="#沟通问题" class="headerlink" title="沟通问题"></a>沟通问题</h3><p>你与团队成员、上司和高管的沟通方式会因每个团队而不同。有时，面试官可能期望了解你是如何对不同等级的人沟通的，以及在遇到紧急情况时你能够向受影响的人传递怎样的信息；另外，也想了解你对整个业务的熟悉程度，当系统故障导致业务停止或者离线时，会影响哪些关联业务和系统，这个时候你会如何及时与正确的人进行沟通等。</p><p>这部分的问题将涵盖比较多的话题，包括内部流程、故障恢复和沟通等等。</p><blockquote><p>下面十个问题都有一小段注解，因文章过长，未翻译</p></blockquote><ol start="21"><li>在危机时刻，你如何将重要信息传递给高层管理人员？</li><li>你如何管理故障恢复？</li><li>在项目管理中，你最强的技能是？</li><li>你遇到过的最大的 IT 从业相关的挑战是？</li><li>你如何同时处理多个项目截止时间？</li><li>文档对你有多重要？</li><li>基于我们之前所聊，你觉得可以对 IT 部门作出哪些改变</li><li>在获取心的软件或硬件时你会如何协商？</li><li>你如何确保公司数据的安全性以及操作不受安全漏洞或事件的影响？</li><li>沟通对你的管理策略有多重要？</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>面试管理岗的职位通常会让人有点压力，即使你在这个方向已经有了很长的经验。毕竟，是否能够高效带领团队决定了公司能否走向成功，因为团队停止工作，即使只有一分钟，那也是在浪费公司的资源，你需要让你的团队一直处于工作状态。</p><p>记得在面试之前练习下回答这些问题，思考下你会为这些问题准备怎样的答案。提前思考，会让你在面试的时候回答得更自然，更好地展现你的个人能力！</p><hr><p>译者注：这篇文章比较长，每个问题后面都有一小段注解，我觉得重要的是问题，答案感兴趣的话，读者可以去原文查看。</p><p>逐字逐句的翻译真的是浪费生命，后续的翻译我会根据自己习惯的语序和风格翻译大概的意思，省时省力，太多国外的作者在表达的时候不注重前后逻辑，翻译起来异常痛苦。当然，也可能是我理解能力的问题 ；）</p><p>后续翻译也尽量不选择长文，翻译起来实在是太费时间了，如果每篇文章都是超级长文，我估计今年没有办法实现 100 篇的翻译目标了=。 =</p>]]></content:encoded>
      <comments>http://www.barretlee.com/blog/2019/04/23/top-30-it-manager-interview-qa/#comments</comments>
    </item>
    
  </channel>
</rss>
